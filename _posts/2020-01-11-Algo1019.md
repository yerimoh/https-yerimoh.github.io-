---
title: "[1019] (파이썬)leet code_125. Valid Palindrome"
date:   2020-01-11
excerpt: "팰린드롬, 회문"
category: [Coding test]
layout: post
tag:
- Coding test
comments: true
---

# 목차

- [전체 코드](#전체-코드)


-----

👀, 🤷‍♀️ , 📜    
이 아이콘들을 누르시면 코드, 개념 부가 설명을 보실 수 있습니다:)

------





# 유효한 팰린드롬
난이도 | ★        


## 문제

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.     




**Example 1:**      
```
Input: s = "A man, a plan, a canal: Panama"
Output: true
#Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**   
```
Input: s = "race a car"
Output: false
#Explanation: "raceacar" is not a palindrome.
```

**Example 3:**
```
Input: s = " "
Output: true
#Explanation: s is an empty string "" after removing non-alphanumeric characters.
#Since an empty string reads the same forward and backward, it is a palindrome.
```

**[전제]**    
```
* 1 <= s.length <= 2 * 105
* s consists only of printable ASCII characters.
```

---
----


# '팰린드롬' 이란?     
앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장이다.     

우리 말로는 '회문'이라고 부른다.   

예를 들어,    
race a car를 보자. 이 문장에 띄어쓰기를 없애면 raceacar이다.     

이 문장은 뒤집어도 race a car이다.     

이러한 팰린드롬의 특징을 이용하면 많은 문제들을 만들어 낼 수 있기 때문에 코딩 테스트에 자주 출제되기도 한다.    


-------





# 풀이과정 



----

## 0. 중첩 리스트 Nested List 표현
먼저 단계별로 처리하기 전, 처리를 쉽게 하기 위해 board로 넣어보겠다!     
* 문자열을 문자 단위 리스트로 분리하여 중첩 리스트 Nested List 표현       

```python
# 리스트 안에 리스트가 들어가 있으므로 중첩 리스트이다
# [list(x)] 
board = [list(x) for x in board] 
```

<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/MZYdItExjgjnDF" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> </div>
</div>


-----

## 1. 일치 여부 판별
먼저 지워지는 조건을 다시보자.     
* 블록이 2×2 형태로 4개가 붙어있을 경우    
* 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다    

어렵게 생각할 것 없이 이 조건 그래도 구현하면 된다.

그런데 코드가 딱 보기 힘드니 세부적인 과정을 알려주고 전체적인 과정을 보려주겠다.     
먼저 각 if문에서의 처리는 아래와 같다    



<details>
<summary>👀코드 보기</summary>
<div markdown="1">
  
```python
for i in range(m - 1):
	for j in range(n - 1):
	    # 이 코드가 2x2의 네모  범위 내에 존재하는 것들이 같은지를 물어보는 것이다
	    # != '#' 얘는 찾은 네모가 이미 찾은게 아닌지를 물어보는것이다
	    ## 안찾은것만 넣어야 하니(#을 넣지 말아야하니) #이 아닌 때만 추가해 주는 것이다
	    if board[i][j] == board[i][j + 1] == board[i + 1][j + 1] == board[i + 1][j] != '#':
	        matched.append([i, j])
```
  
</div>
</details>

<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/8a4LNxVCe1KiKu" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"> </div>
</div>






그럼 이제 이 2x2 if문 처리를 한 뭉텅이로 보고 전체 1번 코드를 돌아보겠다!



<details>
<summary>👀코드 보기</summary>
<div markdown="1">
  
```python
matched = True 
while matched:
	# 1) 일치 여부 판별 
	matched = [] 
	for i in range(m - 1):
	    for j in range(n - 1):
	        # 이 코드가 2x2의 네모  범위 내에 존재하는 것들이 같은지를 물어보는 것이다
		# != '#' 얘는 찾은 네모가 이미 찾은게 아닌지를 물어보는것이다
		## 안찾은것만 넣어야 하니(#을 넣지 말아야하니) #이 아닌 때만 추가해 주는 것이다
		if board[i][j] == board[i][j + 1] == board[i + 1][j + 1] == board[i + 1][j] != '#':
	            matched.append([i, j])
```
  
</div>
</details>


<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/6lUhrH91Bg4raM" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"></div>
</div>


-----

## 2. 일치한 위치 삭제 
이 단계에서 아까 모아둔 조건을 만족하는 match의 좌표를 #으로 바꿔주기만 하면 된다

<details>
<summary>👀코드 보기</summary>
<div markdown="1">
  
```python
for i, j in matched:	        
	board[i][j] = board[i][j + 1] = 
	board[i + 1][j + 1] = board[i + 1][j] = '#'

```
  
</div>
</details>


<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/qqvMPByXyvjzwe" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"><a href="https://www.slideshare.net/YerimOh8" target="_blank">YerimOh8</a></strong> </div>
</div>



-----


## 3. 빈공간 블럭 처리 
'#'이라는 빈 부분 ```[i + 1][j]``` 이 있으면 위의 비지 않은 부분```board[i][j]```과 바꿔준다   

<details>
<summary>👀코드 보기</summary>
<div markdown="1">
  
```python
	    
# 3) 빈공간 블럭 처리 
for _ in range(m):
	for i in range(m - 1):
	        for j in range(n):
		# '#'이라는 빈 부분 ```[i + 1][j]``` 이 있으면 위의 비지 않은 부분```board[i][j]```과 바꿔준다
	        	if board[i + 1][j] == '#':
	        		board[i + 1][j], board[i][j] = board[i][j], '#'

```
  
</div>
</details>



<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/N9XoYkOzMu2lOW" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"></div>
</div>

➕ 참고로 이 예시에선 안나왔지만 ```for _ in range(m):```이게 있는 이유는 '맨 위부터 아래까지 내려와야하는 경우도 있어야 하니까'이다.     

---

## 4. 반복

처리 후 또 2X2가 나올 수 있기 때문에 matched가 더이상 없어 False가 될 때 까지 위의 1~3 과정을 반복한다.     


----

## 5. 개수 세기

'지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.' 가 주어진 조건이므로,      

```return sum(x.count('#') for x in board)```으로 '#'의 개수를 세면 답이 나온다

-----
----

# 전체 코드

모든 비즈니스 로직을 구현한 전체 코드는 다음과 같다

```python
def solution(m, n, board):
	board = [list(x) for x in board]
	
	matched = True 
	while matched:
	    # 1) 일치 여부 판별 
	    matched = [] 
	    for i in range(m - 1):
	        for j in range(n - 1):
	            if board[i][j] == board[i][j + 1] == board[i + 1][j + 1] == board[i + 1][j] != '#':
	                matched.append([i, j])
	    
	    # 2) 일치한 위치 삭제 
	    for i, j in matched:
	        board[i][j] = board[i][j + 1] = board[i + 1][j + 1] = board[i + 1][j] = '#'
	    
	    # 3) 빈공간 블럭 처리 
	    for _ in range(m):
	        for i in range(m - 1):
	            for j in range(n):
		        # '#'이라는 빈 부분 ```[i + 1][j]``` 이 있으면 위의 비지 않은 부분```board[i][j]```과 바꿔준다
	                if board[i + 1][j] == '#':
	                    board[i + 1][j], board[i][j] = board[i][j], '#'
	
	return sum(x.count('#') for x in board)
```


