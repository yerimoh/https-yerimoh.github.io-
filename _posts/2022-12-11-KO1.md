---
title: "[01] Kotlin:"
date:   2022-12-11
excerpt: "Learn App with Kotlin"
category: [App]
layout: post
tag:
- Kotlin
- App
order: 0

comments: true
---


# **안드로이드 앱의 기본구조**     

# **안드로이드 앱 개발의 특징**   

## 컴포넌트 기반의 개발
안드로이드 앱 개발의 핵심은 **컴포넌트 component** 이다.              


**[컴포넌트는 애플리케이션의 구성 요소임]**      
* 컴포넌트는 안드로이드 앱뿐만 아니라 여러 애플리케이션을 개발할때 사용하는 개념   
* 컴포넌트를 한마디로 정의하면 **애플리케이션의 구성 요소**라고 할 수 있음   
* 컴포넌트는 애플리케이션이 아니라 **애플리케이션을 구성하는 단위**       
* 즉, 하나의 애플리케이션은 여러 컴포넌트로 구성 됨       
* 안드로이드 앱의 기본 구조도 컴포넌트에 기반을 두므로 하나의 앱은 여러 컴포넌트로 구성됨.    
* 그리고 **안드로이드에서는 클래스로 컴포넌트를 개발**함.       
* 즉, **하나의 클래스가 하나의 컴포넌트**가 되는 것임     



**[안드로이드 앱을 구성하는 클래스는 모두 컴포넌트인가?]**     
* 애플리케이션을 구성하는 모든 클래스가 컴포넌트는 아님        
* 앱은 여러 클래스로 구성되는데 크게 **컴포넌트 클래스**와 **일반 클래스**로 구분함     
* 둘다 개발자가 만드는 클래스지만 **런타임 때 생명주기를 누가 관리하는가**에 따라 차이가 있음      
* 일반 클래스       
   * 앱이 실행될 때 클래스의 객체 생성부터 소멸까지 생명주기 관리를 개발자 코드에서 함     
   * 안드로이드 앱의 구성 요소인 컴포넌트가 아닌 개발자가 임의의 목적 으로 만든 클래스       
* 컴포넌트 클래스          
   * 개발자가 만들기는 했지만 생명주기를 안드로이드 시스템 에서 관리      


**[안드로이드 컴포넌트의 4가지 종류]**      
* 컴포넌트는 액티비티, 서비스, 콘텐츠 프로바이더, 브로드캐스트 리시버 이렇게 4가지로 구분됨     
* 컴포넌트는 앱이 실행될 때 각각 다른 기능을 함         
* **액티비티**      
   * 화면을 구성하는 컴포넌트      
   * 앱의 화면을 안드로이드폰에 출력하려면 액티비티를 만들어야 함     
   * 앱이 실행되면 액티비티에서 출력한 내용이 안드로이드폰에 나옴        
* **서비스**      
   * 백그라운드 작업을 하는 컴포넌트      
   * 화면 출력 기능이 없으므로 서비스가 실행 되더라도 화면에는 출력되지 않음      
   * 서비스 컴포넌트는 화면과 상관없이 백그라운드에서 장시간 실행해야 할 업무를 담당함        
* **콘텐츠 프로바이더**     
   * 앱의 데이터를 공유하는 컴포넌트       
   * 안드로이드폰에는 많은 앱이 설치되어 있으며 앱 간에 데이터를 공유 가능    
   * 하나의 앱이 자신의 데이터를 다른 앱에 공유하려면 콘텐츠 프로바이더를 만들어야 하며, 다른 앱에서는 그 콘텐츠 프로바이더를 이용해 데이터에 접근함       
   * 예를 들어 카카오톡 앱에서 프로필을 변경할 때 갤러리 앱의 사진을 이용할 수 있는데, 이때 콘텐츠 프로바이더를 이용해 데이터를 주고받음      
* **브로드캐스트 리시버**      
   * 시스템 이벤트가 발생할 때 실행되게 하는 컴포넌트       
   * 여기서 이벤트는 화면에서 발생하는 사용자 이벤트가 아니라 **시스템에서 발생하는 특정 상황**을 의미      
   * 예를 들어 부팅 완료, 배터리 방전 같은 상황임        


**[4가지 컴포넌트 구분 방법]**      
* 컴포넌트는 앱이 실행될 때 안드로이드 시스템에서 생명주기를 관리하는 클래스지만 **개발자가 만들어야 하는 클래스**임      
* 개발자가 컴포넌트 클래스를 만들 때는 **지정된 클래스를 상속받아야 하는데** 이 **상위 클래스를 보고 구분**할 수 있음       
* **액티비티**는 ```Activity``` 클래스를 상속받아 만듦    
* **서비스**는 ```Service``` 클래스를 상속받아 만듦      
* **콘텐츠 프로 바이더**는 ```ContentProvider``` 클래스를 상속받아 만듦     
* **브로드캐스트 리시버**는 ```BroadcastReceiver``` 클래스를 상속받아서 만듦       


**[main 함수가 없다]**    
* 앱은 실행 시점이 다양함     
* 컴포넌트가 앱 내에서 독립해서 실행되는 특징 덕분에 앱의 실행 시점이 다양할 수 있음     
* 일반적으로 앱을 설치하면 홈 화면에 아이콘이 나오고 그 아이콘을 사용 자가 터치해서 실행함     
* 예를 들어 사용자가 알림 창에서 메시지 수신 알림을 터치하면 바로 채팅 화면이 열립니다.     
이처럼 앱의 실행 시점은 다양함    
* 그래서 안드로이드 앱에는 메인 함수 main function 개념이 없다고 말함      
* 메인 함수란 앱의 단일 시작점을 의미하는데 안드로이드 **앱은 실행 시점이 다양**해서 메인 함수 개념이 없다고 표현하는 것임            


-----


## 리소스를 활용한 개발
앞에서 살펴본 컴포넌트와 함께 안드로이드 앱 개발의 또 다른 특징은 리소스를 많이 활용 한다는 점임     

**리소스**     
* 코드에서 정적인 값을 분리한 것        
* 앱에서 발생하는 데이터나 사용자 이벤트에 따른 동적인 값이 아니라 **항상 똑같은 값**이라면 굳이 코드에 담지 않고 **분리해서 개발**하는 것이죠.    
➡ 이렇게 하면 코드가 짧아져서 개발 생산성과 유지·보수성이 좋아짐     



**[문자열을 리소스로 이용]**      
대표적인 예가 문자열을 리소스로 이용하는 것임       
만약 화면에 애국가 가사를 출력한다면 다음처럼 코드를 작성함       

```kotlin
/문자열을 코드로 작성하기/

textView.text = ”””
동해 물과 백두산이 마르고 닳도록 
하느님이 보우하사 우리나라 만세 
무궁화 삼천리 화려 강산 대한 사람, 
대한으로 길이 보전하세
“””
```

그런데 **문자열이 항상 똑같다면** 코드에 담지 않고 다음처럼 **리소스로 등록해서 사용**하는 게 효율적         

```kotlin
/문자열을 리소스로 등록하기/
<string name=”mytxt”>
동해 물과 백두산이 마르고 닳도록 
하느님이 보우하사 우리나라 만세 
무궁화 삼천리 화려 강산 대한 사람, 
대한으로 길이 보전하세
</string>
```	

이렇게 리소스로 등록해 두면 다음처럼 간편하게 사용 가능
/kotlin
/문자열 리소스 사용 예/
textView.text = resources.getString(R.string.mytxt)
```


**[특징]**    
* 이처럼 안드로이드 앱을 개발할 때는 많은 요소를 리소스로 등록해서 사용함      
* 앞으로 자세히 다루겠지만 문자열 이외에 색상, 크기, 레이아웃, 이미지, 메뉴 등 많은 요소를 리소스로 활용할 수 있음    
* 또한 이미지 등 몇몇을 제외하면 대부분 리소스는 XML 파일로 작성함      

02-3 앱 구성 파일 분석
안드로이드 프로젝트를 만들면 자동으로 완성되는 “Hello World!” 문자열 출력 앱을 살펴보 면서 앱을 구성하는 파일과 코드를 분석해 보겠습니다.
프로젝트의 폴더 구성 알아보기
안드로이드 앱 프로젝트를 만들면 많은 폴더와 파일이 생성됩니다. 하지만 대부분은 빌드 도구와 관련된 것이며 개발자가 관심을 둬야 할 파일은 프로젝트 폴더에서 [모듈명 → src → main] 안에 있습니다. 다음 그림은 윈도우의 파일 탐색기에서 main 폴더를 찾은 예입니다.
그림 2-13 윈도우의 파일 탐색기에서 본 폴더 구조
그런데 안드로이드 스튜디오의 프로젝트 탐색 창은 윈도우 파일 탐색기처럼 모든 폴더와 파일을 보여 주지 않습니다. 개발 자가 분석하거나 작성해야 하는 폴더와 파일만 보여 줍니다.

프로젝트를 만들면 app이라는 모듈이 자동으로 생성됩니다. 모듈 하나가 앱 하나 * 이며 프로젝 트는 여러 모듈을 묶어서 관리하는 개념입니다. 하나의 프로젝트에는 자동으로 만들어지는 app 모듈 이외에 여러 모듈을 추가할 수 있습니다. 모듈은 앱 단위이므로 새로운 모듈을 추가한 다는 것은 새로운 앱을 개발한다는 것과 같습니다. 모듈을 추가하는 방법은 이후에 자세하게 다루겠습니다.
모듈의 폴더 구성 알아보기
모듈은 어떤 폴더와 파일로 구성되는지 알아보겠습니다.
이름 설명
build.gradle 빌드 설정 파일 AndroidManifest.xml 앱의 메인 환경 파일 res 리소스 폴더 activity_main.xml 레이아웃 XML 파일 MainActivity.kt 메인 액티비티 파일
그래들 빌드 설정 파일
그래들 gradle 은 안드로이드 앱의 빌드 도구입니다. 그래들의 설정 파일이 바로 build.gradle이 며(이하 ‘그래들 파일’) 앱을 빌드하는 데 필요한 설정을 이 파일에 등록합니다. 그래들 파일은 안드로이드 스튜디오의 탐색 창에서 코끼리 모양의 아이콘이 있는 [Gradle Scripts]에서 찾을 수있습니다.
그런데 탐색 창을 보면 build.gradle 파일이 2개 있습니다. 하나는 프로젝트 수준의 build.
gradle (Project: AndroidLab)이고, 또 하나는 모듈 수준의 build.gradle (Module:
AndroidLab.app)입니다. 모듈은 앱을 의미하므로 대부분의 빌드 설정은 모듈 수준의 그래들 파일에 작성합니다.
모듈 수준의 그래들 파일을 열어 보면 몇 가지 설정이 자동으로 등록돼 있습니다. 이 값을 수정하거나 새로 추가하면서 빌드 환경을 설정합니다. 중요한 설정 몇 가지만 살펴보겠습니다.

플러그인 선언
plugins { id ‘com.android.application’ id ‘kotlin-android’ }
위의 코드는 플러그인을 선언한 것입니다. 기본적으로 com.android.application과 kotlinandroid 플러그인이 선언되어 있으며 필요에 따라 추가할 수 있습니다.
• 컴파일 버전 설정
compileSdk 31
이 코드는 앱을 컴파일하거나 빌드할 때 적용할 버전을 설정합니다. compileSdk 31로 지정되어 있으면 안드로이드 SDK 31 버전을 적용해서 컴파일하라는 의미입니다.
• 앱의 식별자 설정
applicationId “com.example.androidlab”
applicationId는 앱의 식별자를 설정합니다. 이곳에 지정한 문자열은 앱의 식별자가 되므로 고유한 문자열로 지정해야 합니다. 만약 구글 플레이 스토어에 등록된 어떤 앱이 똑같은 식별 자를 이미 사용하고 있다면 이 앱은 플레이 스토어에 등록되지 않습니다. 또, 스마트폰에 식별자가 똑같은 앱이 설치되어 있다면 이 앱은 설치되지 않습니다.
• SDK 버전 설정
minSdk 21
targetSdk 31
targetSdk는 개발할 때 적용되는 SDK 버전입니다. 31로 지정하면 31 버전의 SDK로 개발한 다는 의미입니다. 그리고 minSdk는 이 앱을 설치할 수 있는 기기의 최소 SDK 버전을 의미합 니다. 만약 21로 지정하면 21 버전까지 지원한다는 의미이며 그 아래 버전의 기기에는 설치 되지 않습니다. SDK 버전 설정은 10장에서 API 레벨 호환성을 다룰 때 더 자세하게 소개합 니다.

minSdk 설정값을 1로 지정하면 되잖아요? 그러면 모든 스마트폰에 앱이 설치될 테니 까요.
그렇기는 합니다. minSdk를 1로 지정하면 모든 안드로이드 기기에 앱이 설치됩니다. 그런데 그렇게 하려면 1 버전까지 오류 없이 잘 동작하도록 앱을 개발해야 합니다. 이처럼 하위 버전에서도 오류가 발생하지 않게 개발하는 것을 하위 호환성이라고 하는데 그리 쉬운 작업은 아닙니다.
새로운 안드로이드 버전이 출시되면서 API도 시스템 정책도 많이 바뀌었습니다. 이 때문에 하위 버전에서는 오류가 발생할 수 있습니다. 그런데 만약 21 아래 버전의 스마트폰 사용자가 0.001%뿐이라면 어떨까요? 0.001%의 사용자까지 고려해서 하위 호환성을 갖출 것인 지를 생각해 봐야 합니다.
따라서 대부분은 버전 점유율을 보고 중간 버전에서 minSdk값을 지정합니다. 2021년 말을 기준으로 안드로이드 프로젝트를 만들면 기본으로 minSdk값이 21로 선언되지만 실제 개발 현장에서는 이보다 더 높이는 추세입니다.
다음 코드는 앱의 버전을 설정합니다. 초깃값은 1이지만 앱이 사용자의 스마트폰에 설치되어 이용되다가 업데이트될 때 이 버전을 올려 다시 배포합니다.
다음 코드는 개발 언어의 버전을 설정합니다. 참고로 자바 버전 선언을 생략하면 기본으로 1.6이 적용됩니다.
• 컴파일 옵션
• 앱의 버전 설정
versionCode 1
versionName “1.0”
compileOptions { sourceCompatibility JavaVersion.VERSION_1_8
targetCompatibility JavaVersion.VERSION_1_8
} kotlinOptions { jvmTarget = ‘1.8’ }
66 첫째마당•안드로이드 앱 개발 준비하기

다음 코드는 앱에서 이용하는 라이브러리의 버전을 설정합니다.
}
targetSdk에 명시한 안드로이드 SDK는 기본으로 적용되지만 그 외에 개발자가 추가하는 오픈소스 라이브러리나 구글의 androidx 라이브러리 등 SDK 라이브러리가 아닌 것들은 모두 dependencies에 선언해야 합니다. 실제 개발할 때는 dependencies에 많은 라이브러리를 선언합니다. 즉, 안드로이드 앱은 보통 안드로이드 SDK 라이브러리만으로 개발하지는 않습니다.
메인 환경 파일
AndroidManifest.xml은 안드로이드 앱의 메인 환경 파일입니다(이하 ‘매니페스트 파일’).
개발을 진행하면서 매니페스트 파일을 분석하고 수정하는 일이 많은데 안드로이드 시스템은이 파일에 설정한 대로 사용자의 폰에서 앱을 실행합니다. 즉, 매니페스트 파일은 개발부터 실행까지 중요한 역할을 합니다.
매니페스트 파일에서 중요한 부분만 설명해 보겠습니다.
• 네임스페이스 선언
• 라이브러리 설정
dependencies { implementation 'androidx.core:core-ktx:1.7.0'
implementation 'androidx.appcompat:appcompat:1.4.0'
implementation 'com.google.android.material:material:1.4.0'
implementation 'androidx.constraintlayout:constraintlayout:2.1.2'
testImplementation 'junit:junit:4.+' androidTestImplementation 'androidx.test.ext:junit:1.1.3'
androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'
<manifest xmlns:android=”http://schemas.android.com/apk/res/android” package=”com.example.androidlab”>
라이브러리 버전은 시기에 따라 책과 다를 수 있어요.
<manifest>는 매니페스트 파일의 루트 태그입니다. 그리고 xmlns는 XML의 네임스페이스 선언이며 URL이 http://schemas.android.com/apk/res/android로 선언되었다면 안드로이드 표준 네임스페이스입니다. package는 매니페스트 파일에 선언한 컴포넌트 클래스의 기본 패키지명입니다. 이후 매니페스트 파일에 선언되는 액티비티, 서비스 클래스 등의 경로는 이패키지명 이후부터 작성하면 됩니다.

네임스페이스 선언
<application android:allowBackup=”true” android:icon=”@mipmap/ic_launcher” android:label=”@string/app_name” android:roundIcon=”@mipmap/ic_launcher_round” android:supportsRtl=”true” android:theme=”@style/Theme.AndroidLab”> (... 생략 ...) </application>
<application> 태그는 앱 전체를 대상으로 하는 설정입니다. <application> 태그에는 앱의 아이콘을 설정하는 icon 속성이 있는데 이곳에 지정한 이미지가 앱을 설치한 사용자의 폰에 보이는 실행 아이콘입니다. 예에서 icon 속성에 지정한 @mipmap/ic_launcher는 res/mip map/ic_launcher.png 파일을 의미합니다. XML의 속성값이 @으로 시작하면 리소스를 의미 합니다.
label 속성에는 앱의 이름을 등록하는데 @string/app_name으로 지정했으므로 res/values/ strings.xml 파일에 app_name으로 등록된 문자열 리소스를 가리킵니다. theme 설정은 앱에 적용해야 하는 테마를 설정하는 것으로 res/values/themes.xml 파일에 Theme.AndroidLab 이름으로 선언한 테마를 적용하겠다는 의미입니다.
앞에서 살펴본 바와 같이 안드로이드 컴포넌트는 시스템에서 생명주기를 관리합니다. 그리고 시스템은 매니페스트 파일에 있는 대로 앱을 실행합니다. 결국 컴포넌트는 매니페스트 파일에 등록해야 시스템이 인지합니다.
• 액티비티 선언
<activity android:name=”.MainActivity”> <android:exported="true"> <intent-filter> <action android:name=”android.intent.action.MAIN” /> <category android:name=”android.intent.category.LAUNCHER” /> </intent-filter> </activity>

액티비티는 <activity> 태그로, 서비스는 <service> 태그로, 브로드캐스트 리시버는 <recei ver> 태그로, 그리고 콘텐츠 프로바이더는 <provider> 태그로 등록합니다. 컴포넌트 하나당 태그 하나로 등록하며 만약 액티비티가 10개라면 <activity> 태그를 10개 선언해야 합니다.
액티비티를 등록할 때 필수 속성은 name입니다. name 속성에는 클래스 이름을 등록합니다. 예를 들어 name=”.MainActivity”라고 했다면 MainActivity 클래스를 액티비티로 등록하겠다는 의미입니다. 클래스 이름 앞에 있는 점(.)은 해당 클래스가 <manifest> 태그에 등록한 package 경로에 있다는 의미입니다.
<intent-filter> 태그는 생략할 수 있습니다. 이 태그를 자세히 설명하려면 안드로이드에서 중요한 역할을 하는 인텐트를 설명해야 하지만 지금은 조금 이릅니다. 여기서는 <intentfilter> 태그의 의미 정도만 간단하게 파악하고 넘어가겠습니다. <intent-filter>가 선언되 었고 그 안에 <action> 태그의 name값이 android.intent.action.MAIN 문자열로, <category> 태그의 name값이 android.intent.category.LAUNCHER로 선언되면 이 액티비티는 앱 아이콘을 클릭했을 때 실행되는 액티비티라는 의미입니다. 앱이 설치되면 홈 화면에 앱 아이콘이 나오는 데, 이 아이콘을 터치했을 때 실행되어야 하는 액티비티라는 의미입니다.
깡샘!
질문 있어요!
<activity> 태그의 <intent-filter> 부분을 생략하면 사용자가 아이콘을 터치했을 때 어떤 액티비티가 실행되나요?
만약 앱에 < a c t i v i t y >를 선언했는데 a n d r o i d . i n t e n t . a c t i o n . M A I N으로 등록한 <action> 태그와 android.intent.category.LAUNCHER로 등록한 <category> 태그를 포함하는 <intent-filter>가 없다면, 이 앱은 설치는 되지만 앱 아이콘은 나오지 않습니 다. 즉, 이 앱은 사용자가 직접 실행할 수 없습니다. 일반적으로 사용자가 실행할 수 없는 앱은 의미가 없지만 때로는 목적에 따라 아이콘이 나오지 않게 설정하기도 합니다. 예를 들면 다른 앱과 연동하는 용도의 앱 같은 경우입니다.
리소스 폴더
res 폴더는 앱의 리소스를 등록하는 목적으로 사용합니다. 모듈이 만들어지면 res 폴더 아래에 다음과 같은 폴더가 기본으로 생깁니다.
• drawable: 이미지 리소스 • layout: UI 구성에 필요한 XML 리소스

mipmap: 앱 아이콘 이미지 • values: 문자열 등의 값으로 이용되는 리소스
그림 2-16 리소스 추가
res 폴더 아래에 리소스를 만들면 자동으로 R.java 파일에 상수 변수로 리소스가 등록되며 코드에서는 이 상수 변수로 리소스를 이용합니다. R.java는 개발자가 만드는 파일이 아니며 res 폴더에 있는 리소스를 보고 자동으로 만들어집니다.
예전 버전의 안드로이드 스튜디오에서는 R.java 파일을 찾아 확인해 볼 수 있었으나 버전이 오르고서는 이제 R.java 파일을 보여 주지는 않습니다. R.java 파일은 개발자가 직접 건드리지 않고 내부에서 리소스를 등록하기 위해 사용하기 때문입니다.
만약 그림처럼 개발자가 res/drawable 폴더에 person1.
png 파일과 send.png 파일을 만들었다면 이 리소스를 식별하기 위한 int형 변수가 R.java 파일에 등록됩니 다. 그리고 코드에서 이 리소스 파일을 이용하려면 R.dra w a b l e.p e r s o n1과 R.d r a w a b l e.s e n d로 식별합니다.
R.java 파일에 각 폴더의 하위 클래스가 만들어지고 그안에 파일명을 기준으로 int형 변수가 자동으로 만들어 집니다. 따라서 res/drawable/send.png 파일이라면 R.drawable.send라고 이용합니다.
마찬가지로 layout 폴더에 text.xml 파일을 만들면 이 리소스를 식별하기 위한 int형 변수가 R.java 파일에 만들어집니다. R.java 파일에 layout이라는 하위 클래스가 생기고 그 안에 파일명으로 int형 변수가 만들어집니다. 따라서 res/layout/test.xml 파일이라면 R.layout.
test라고 이용합니다.
이처럼 안드로이드 리소스 파일이 R.java 파일에 상수 변수로 등록되어 이용되면서 다음과 같은 규칙이 생깁니다.
• res 하위의 폴더명은 지정된 폴더명을 사용해야 합니다.
• 각 리소스 폴더에 다시 하위 폴더를 정의할 수는 없습니다.
• 리소스 파일명은 자바의 이름 규칙을 위배할 수 없습니다.
• 리소스 파일명에는 알파벳 대문자를 이용할 수 없습니다.
이런 식으로 리소스가 등록되면 R.java 파일에 int형 변수가 생기므로 res 폴더에는 개발자

임의의 폴더를 사용할 수 없습니다. 지정된 폴더명을 사용해야 한다는 의미입니다. 즉, 이미 지는 drawable 폴더를, UI 관련 XML 파일은 layout 폴더를 이용해야 하며, 각 리소스 폴더에 하위 폴더를 만들 수 없습니다.
또한 리소스 파일명은 R.java 파일에 변수명으로 사용되므로 자바의 이름 규칙에 어긋나는 파일명은 정의할 수 없습니다. 자바 이름은 숫자로 시작할 수 없다는 규칙이 있으므로 리소스 파일명으로 a1.png는 가능하지만 1a.png는 불가능합니다. 그런데 리소스 파일명에는 자바 이름 규칙에서 허용하는 알파벳 대문자를 사용할 수 없습니다. 따라서 addUser.xml처럼 파일명에 알파벳 대문자를 사용하면 안 됩니다. 그래서 두 단어를 연결할 때는 add_user.xml처럼 밑줄(_)을 이용해 정의하는 것이 일반적입니다.
레이아웃 XML 파일
res/layout 폴더 아래 기본으로 만들어지는 activity_main.xml 파일은 화면을 구성하는 레이아웃 XML 파일입니다.
• 레이아웃 XML 파일
<?xml version=”1.0” encoding=”utf-8”?> <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=”http://schemas.android.com/apk/res/android” xmlns:app=”http://schemas.android.com/apk/res-auto” xmlns:tools=”http://schemas.android.com/tools” android:layout_width=”match_parent” android:layout_height=”match_parent” tools:context=”.MainActivity”> <TextView android:id=”@+id/textView” android:layout_width=”wrap_content” android:layout_height=”wrap_content” android:text=”Hello World!”
app:layout_constraintBottom_toBottomOf=”parent” app:layout_constraintLeft_toLeftOf=”parent” app:layout_constraintRight_toRightOf=”parent” app:layout_constraintTop_toTopOf=”parent” /> </androidx.constraintlayout.widget.ConstraintLayout>

이 파일을 열어 보면 <androidx.constraintlayout.widget.ConstraintLayout> 태그와 <TextView> 태그가 등록되어 있습니다. 두 태그에 관한 자세한 내용은 화면을 프로그래밍하는 방법을 설명하는 곳에서 다루기로 하고, 여기서는 화면을 구성하는 요소라고 알아 두면 됩니다.
<TextView>는 화면에 문자열을 출력하는 역할을 합니다. <TextView> 태그의 속성에 android:
text=”Hello World!”라고 선언되었는데 “Hello World!”라는 문자열을 출력하라는 의미입 니다. 결국 기본으로 만들어진 activivty_main.xml 파일은 화면에 “Hello World!”를 출력 하는 구성입니다.
메인 액티비티 파일
앞에서 살펴본 매니페스트 파일의 설정값에 따라 폰에 앱을 설치한 후 앱 아이콘을 터치하면 MainActivity.kt 파일이 실행됩니다.
• 메인 액티비티 파일
class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState)
setContentView(R.layout.activity_main) } }
파일 내용을 간략하게 살펴보면 AppCompatActivity를 상속받아 MainActivity라는 클래스를 정의했습니다. AppCompatActivity는 Activity의 하위 클래스입니다. 따라서 MainActivity 는 액티비티 컴포넌트 클래스입니다. 즉, 이 클래스는 화면 출력을 목적으로 하는 액티비티 클래스라는 의미입니다.
MainActivity 클래스가 실행되면 onCreate() 함수가 자동으로 호출되며 onCreate() 함수 안의 구문을 실행합니다. 여기서 setContentView() 함수는 매개변수에 지정한 내용을 액티 비티 화면에 출력합니다. 이번 코드에서는 R.layout.activity_main으로 지정했으므로 res/ layout/activity_main.xml 파일에 구성한 내용을 화면에 출력합니다.

Do it! 깡샘의 안드로이드 프로그래밍 with 코틀린 (개정판)  :  친절한 문법 설명과 18개 실습 예제로 배우는 모바일 앱 개발 | 강성윤

[YES24 eBook] 
http://m.yes24.com/Goods/Detail/106370800
