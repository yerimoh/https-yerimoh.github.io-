---
title: "[013] Computer Network: TCP(1) 전송 계층의 기능"
date:   2021-02-23
excerpt: "전송 계층의 기능, 전송 계층의 주요 기능(흐름 제어,오류 제어,분할과 병합,서비스 프리미티브), 전송 계층 설계 시 고려 사항(주소 표현, 멀티플렉싱, 연결 설정과 해제)"
category: [CS basic]
layout: post
tag:
- CS basic
order: 0

comments: true
---


# 목차
- [**전송 계층의 기능**](#전송-계층의-기능)
- [**전송 계층의 주요 기능**](#전송-계층의-주요-기능)
  * [흐름 제어 Flow Control](#흐름-제어-flow-control)
  * [오류 제어 Error Control](#오류-제어-error-control)
  * [분할과 병합](#분할과-병합)
  * [서비스 프리미티브 Primitive](#서비스-프리미티브-primitive)
- [**전송 계층 설계 시 고려 사항**](#전송-계층-설계-시-고려-사항)
  * [주소 표현 TSAP](#주소-표현-tsap)
  * [멀티플렉싱 Multiplexing](#멀티플렉싱-multiplexing)
  * [연결 설정](#연결-설정)
  * [연결 해제](#연결-해제)


-----


# **전송 계층의 기능**
**[전송 계층 Transport Layer]**          
프로토콜은 오류 제어, 흐름 제어, 데이터 순서화 등의 기능 면에서 데이터 링크 계층과 특징이 유사하다.        
* **데이터 링크 계층**: **물리적인** 전송 선로로 직접 연결된 두 물리적 호스트(컴퓨터나 라우터) 사이의 데이터 전송을 담당     
* **전송 계층**: 네트워크 끝단에 위치하는 통신 주체가 중간의 **논리적인 선**로(라우터로 연결된 컴퓨터 네트워크)를 통해 데이터를 주고받음          


**[전송 계층과 데이터링크 계층의 차이점]**    
* **데이터 링크 계층**    
    * 단순히 물리적인 선로를 통해 데이터를 직접 전달하기 때문에 ~~네트워크 계층의 중개 기능~~이 필요 없다.     
* **전송 계층**      
    * 중간에 위치한 논리적 **네트워크의 중개 기능**을 사용해 전송 기능을 수행한다.    
    * 네트워크에서 제공하는 다양한 논리적 자원(데이터 링크 계층의 기능, 잠재적 기억 장치에 의한 데이터의 저장과 그에 따른 지연 현상)을 사용한다.     

![image](https://user-images.githubusercontent.com/76824611/165247357-2140639f-ff5e-411f-a558-65ae05428888.png)

**[잠재적 기억장치]**       
일반적으로 **기억 장치**는 데이터를 잃어버리지 않게 보관하는 곳이지만,     
이외에도 데이터를 저장했다가 나중에 다시 사용하므로 **시간적으로 지연되는 곳이**라는 관점도 있다.      
➡ 네트워크에 서는 지연이 매우 중요하다.     
➡ 네트워크를 통해 데이터가 전송되면 송수신 호스트 사이에 전송 지연이 발생하고, 중간 네트워크가 전송 과정에서 데이터를 보관하는 효과가 발생하기도 한다.      
➡ 이렇게 네트워크가 입력과 출력 사이에 시간 지연을 주게 되므로 **논리적으로 기억 장치의 기능을** 한다.      
➡ 네트워크 자체를 잠재적 기억 장치라고 표현한다.      


---
---

# **전송 계층의 주요 기능**
데이터 링크 계층에서 사용하는 물리적인 선로는 단순한 반면,    
컴퓨터 네트워크의 구조는 상대적으로 복잡하다.     
➡ 전송 계층 프로토콜을 설계하는 과정에서는 다음과 같이 여러 기능을 고려해야 한다.     

----


## 흐름 제어 Flow Control
**의미**: 전송 계층의 서비스를 이용해 연결을 설정하면 양 끝단의 호스트에서 실행되는 네트워크 프로세스가 데이터를 주고받을 수 있다. 이 과정에서 필요한 주요 기능 중 하나이다.        


**[데이터 링크 계층과 처리가 다른 이유]**     
* 앞서 언급한 것처럼 데이터 링크 계층에서도 라우터 사이의 프레임 전송 과정에서 흐름 제어 기능을 수행한다.      
* 그러나 **라우터를 연결하는 물리적인 선로의 수**는 전송 계층이 관여하는 호스트 사이의 **논리적인 연결의 수보다 상대적으로 적다**.     
* 따라서 두 계층이 지원하는 흐름 제어 기능은 기본 목적을 비롯해 유사한 특징이 많음에도 불구하고, **서로 다른 버퍼 관리 방법이 필요**하다.         


**[흐름제어의 기능]**    
* **데이터 분실 문제**    
   * 수신 프로세스가 송신 프로세스의 **전송 속도**보다 느리게 데이터를 수신하면 버퍼 용량이 초과하여 데이터를 분실할 수 있다.    
   *  이 경우에 송신 프로세스는 타임아웃 기능을 통해 **재전송 과정**을 수행하므로 전체 네트워크의 **전송 효율**이 점점 떨어진다.    
* **분실 문제 해결**       
   * 이론적으로 흐름 제어 기능은 수신 호스트가 **슬라이딩 윈도우 프로토콜의 윈도우 하단 값을 조정**한다.     
   * 즉, **송신 프로세스가 보낼 수 있는** **패킷의 한계를 지정**하는 방법으로 문제를 해결한다.         

----

## 오류 제어 Error Control
**의미**: 데이터를 전송하는 과정에서 발생할 수 있는 오류에는 데이터 링크 계층에서 설명한 것처럼 **데이터 변형**과 **데이터 분실**이 있다.      
➡ 전송 오류가 발생하여 수신 데이터의 내용이 깨지거나 분실되면 **데이터 재전송**에 의한 오류 제어 Error Control 기능에 의해 복구 절차가 진행된다.   


**[데이터의 재전송]**    
* 절차 수신 프로세스의 요구에 의해 이루지는 경우 존재      
* 송신 프로세스 스스로 판단해 이루어 지는 경우 존재   


전송 계층에서 발생하는 오류는 논리적으로 구축된 각 계층의 소프트웨어가 **동작하는 과정에서 데이터를 분실**하는 경우가 대부분이다.     
EX) 전송 데이터를 특정 목적지까지 라우팅 하는 과정에서 네트워크 계층의 기능적 한계나 잘못된 목적지 호스트의 위치 정보에 의해 올바르게 전달되지 않을 수 있다.       


----

## 분할과 병합
**[분할 Segmentation]**      
* 상위 계층에서 전송을 요구한 데이터의 크기가 전송 계층에서 처리할 수 있는 데이터 크기보다 크면 **데이터를 쪼개 전송**해야 한다.     
* 데이터를 **전송하기 전**에 **적합한 크기로 나누는 과정**       

**[병합 Reassembly]**      
* 수신 프로세스가 수신한 데이터를 **원래 크기로 다시 모으는 과정**       
* 수신 프로세스가 상위 계층에 데이터를 보낼 때는 반드시 데이터의 병합 과정을 거쳐야 **계층 구조의 틀이 유지**된다.         


----


## 서비스 프리미티브 Primitive
**의미**: 전송 계층 사용자가 전송 계층 서비스를 사용하기 위한 인터페이스이다.     
* **네트워크 계층**: 제공하는 서비스는 일반적으로 **비신뢰성**을 바탕으로 한 **비연결형 서비스 프리미티브**가 * **전송 계층**: **비연결형** 서비스뿐 아니라, **신뢰성이 향상된 연결형** 서비스도 제공          



---
----


# **전송 계층 설계 시 고려 사항**
전송 계층 프로토콜을 설계할 때 우선 고려할 사항     
* 주소 표현     
* 멀티플렉싱     
* 연결 설정 관리 등       

--

## 주소 표현 TSAP 

**주소 Address**: 네트워크에서 기본적으로 필요한 일반 사항        
**TSAP(Transport Service Access Point)**: 전송 계층의 주소       
➡ TCP/IP 환경에서 사용하는 호스트의 **IP 주소와 포트 번호의 조합**은 네트워크 계층과 전송 계층에서 사용하는 주소 표현 방식의 하나임      
  
주소 표현은 구조적, 비구조적 표현으로 나눌 수 있다.        

**[구조적 표현]**     
* 전화번호나 우편물에 표기되는 주소처럼 **하나의 주소**를 **여러 개의 계층적인 필드로 구분**한다.       
* 이때 필드는 전체 주소 공간의 **상하 계층 관계**를 나타낸다.        
* EX)  ```대한민국:서울:한국대학교:네트워크학과:네트워크연구실:홍길동:50```  
       * 장점: 컴퓨터의 위치를 직관적으로 유추 가능           
       * 필드 값 중에서 마지막 숫자 **50**은 **포트 번호**이다. 
       * **포트번호**: 컴퓨터에는 다수의 통신 포트가 존재하고, 프로세스가 포트를 이용해 통신하므로 **네트워크 프로세스는 포트 번호로 구분**된다.        


**[비구조적 주소 표현]**    
* 주소 값만 해석해서는 컴퓨터의 논리적인 위치를 파악하기 어렵다.      
* 그런데 주소는 자체에 중요 정보를 포함하도록 설계되기 때문에 비구조적인 경우가 많지 않다.      
* 호스트 주소와 관련해서 ```211.223.201.30```과 같은 IP 주소는 네트워크와 호스트의 **계층적인 특성**은 있지만, **위치** 정보와 관련해서는 **비구조적이**라고 볼 수 있다.       
* 그에 비해 ```www.korea.co.kr```과 같은 도메인 주소는 **구조적인 위치 정보를 제공**한다.        


---

## 멀티플렉싱 Multiplexing
**TPDU(Transport Protocol Data Unit)**: 개별적으로 설정된 전송 계층 연결에서 전송 데이터의 단위     
**멀티플렉싱**: TPDU의 **목적지가 동일한 호스트**이면 이들 데이터를 **하나의 가상 회선에 실어 전송**하는 것이 유리하므로 한번에 전송하는 것이다.             

**[멀티플렉싱의 종류]**
* **상방향 멀티플렉싱**     
    * 다수의 전송 계층 연결에 대해 하부의 네트워크 계층에서 연결이 하나 형성된다.      
    * 따라서 **여러 전송 계층의 연결에서 발생한 데이터**가 동일한 경로로 전송되면 하나의 네트워크 연결에 묶어 전송할 수 있다.       
    * 일반적인 연결 구조보다 네트워크 계층에서 만들어지는 **가상 회선 연결의 개수를 줄일 수** 있으므로 연결 설정에 걸리는 **시간이 단축**된다.       
* **하방향 멀티플렉싱**        
    * 상방향과 반대로 동작한다.       
    * 즉, **하나의 전송 연결 설정**을 의미하는 포트에 **다수의 가상 회선을 할당**한다.       
    * 이 방식으로 데이터를 전송하면 **전송 속도**뿐 아니라, 전송 계층 에서 발생하는 **데이터의 특성에 따라** **개별 가상 회선을 할당**하여 **효과적인 통신**이 가능하다.       
    * EX) 전송 연결에서 송신하고자 하는 데이터의 종류가 영화 파일이면 그 내용을 영상, 음성, 모국어 자막 , 외국어 자막 등으로 구분해 네트워크 연결을 개별적으로 설정할 수 있다.         
    * 구분한 데이터는 오류 허용 범위, 전송률 등의 트래픽 특성이 달라 성격에 맞는 가상 회선을 할당할 수 있기 때문이다.       


![image](https://user-images.githubusercontent.com/76824611/165257747-a61df6f5-898b-480a-b7cc-0d8777e57f7b.png)


----


## 연결 설정
전송 계층의 연결 설정은 **Conn_Req**와  **Conn_Ack**의 회신으로 완료됨       
Conn_ Req 요구를 받은 프로세스가 **연결 요청을 거부**할 수 있다는 의미를 내포하므로 **연결 요청은 양자의 합의**에 의해서만 가능함    
* **Conn_Req**: 연결을 요청하는 프로세스의 연결 설정 요구      
* **Conn_Ack**: 상대편 프로세스에서 연결 수락   

![image](https://user-images.githubusercontent.com/76824611/165266306-342bc21f-a58b-491e-af77-8f54a512ec2e.png)
연결 설정 과정은 개념적으로 모양이 아주 간단하지만, 실제 통신 환경에서는 조금 더 복잡하다.     
예를 들어, 프리미티브가 전달되는 과정에서 분실, 변형, 복사 등의 가능성이 있기 때문에 구현 과정에서 이 문제를 고려해야 한다.   

**[3단계 설정 Three-Way Handshake]**       
* 아래의 그림은 오류가 발생하지 않은 정상 상태에서 3단계 설정 Three-Way Handshake 의 동작 과정을 보여준다.     
* **1)** ```Conn_Req```: A 프로세스는 임의의 송신 순서 번호 x를 지정하여 **연결 설정을 요청**한다.      
* **2)** ```Conn_Ackq```: 이를 수신하는 B 프로세스는 연결 설정 요구에 대한 **순서 번호 x에 대해 응답**을 보낸다.      
➡ 이때 순서 번호 y는 자신의 초기 송신 번호를 왼쪽 프로세스에 알려주기 위해 사용한다.     
* **3)** ```Data_Req```   
    * 연결 요구에 대한 응답 Conn_Ack를 받은 A 프로세스는 Conn_Ack를 **잘 받았다고** B 프로세스에 **응답**해야 한다.    
   ➡ 따라서 Conn_Ack와 다른 종류로 응답 정보를 보내야 하지만, 그림에 서는 이 과정을 생략하고 바로 데이터를 전송하고 있다.    
   ➡ 이는 Data_Req가 데이터 전송과 함께 응답 기능을 함께 수행하기 때문이다. 만일 A 프로세스가 전송할 데이터가 없으면 Conn_ Ack에 대한 응답을 따로 해야 한다.
    * A 프로세스는 Data_Req(x,y)처럼 자신이 설정한 순서 번호 x를 사용해 **데이터를 전송**하고 있다. 이때 데이터 전송과 함께 B 프로세스가 설정한 **순서 번호 y에 대해서도 응답**해야 한다.       

![image](https://user-images.githubusercontent.com/76824611/165266327-aaa757bf-808e-4741-90c9-d59e89d3a88e.png)

---


## 연결 해제
연결 해제 과정은 설정 과정보다는 간단함    
연결 해제 방식은 크게 두가지이다.   
전송 계층은 양방향 데이터 전송을 지원한다.    

**[일방적 연결 해제 절차 방식]**       
통신하는 한쪽 프로세스가 일방적으로 ```Disc_Req```를 전송해 연결 종료를 선언할 수 있다.    
```Disc_Req```에 대한 상대 프로세스의 동의가 없어도 연결이 끊기는 방식이다.     
그림은 양방향 통신을 지원하는 연결을 하나의 원통으로 표현하였으며, 한쪽 프로세스가 ```Disc_Req```를 전송한다는 의미는 이 원통의 기능을 정지시켜, 둘 사이의 연결이 해제되는 것을 의미한다.    
* 문제     
  * 이 방식은 A 프로세스가 B 프로세스에 **전송할 데이터가 남거나**, 전송 중이지만 **아직 완료되지 않은 시간 t**에 상대 프로세스와 **연결 종료**가 이루어진다.     
  ➡ 데이터 전송을 지원하는 원통 기능이 정지되어 **데이터 전송을 완료할 수 없다**는 문제가 발생한다.     

![image](https://user-images.githubusercontent.com/76824611/165266356-bde4799a-3972-40e2-9c3b-c44d3f6a4a78.png) 

**[점진적 연결 해제 절차 방식]**         
**하나의 연결**에 **두 개**의 단방향 **연결을 지원**하는 원통이 존재하는 것과 같다.     
따라서 A 프로세스의 데이터 전송 과정 중에 B 프로세스의 **연결 해제 요구가 발생**해도 **아래쪽 원통 기능만 정지**하고, **위쪽 원통은 여전히 정상 기능을 수행**한다.      
➡ 즉, A 프로세스가 전송해야 하는 데이터를 계속 전송할 수 있다.       
* **완전한 연결 종료**          
    * 두 프로세스 사이의 연결을 완전히 종료하려면 양쪽에서 자신에게 할당된 단방향의 원통 기능을 명시적으로 정지해야 된다.      
    * 두 프로세스 모두 ```Disc_Req```를 전송해야 한다.       


![image](https://user-images.githubusercontent.com/76824611/165266394-4cf46d7a-67fd-4fce-adfc-6c83ca4c2971.png)
