---
title: "[020] Algorithm(그래프 순회 1_깊이 우선 탐색(Depth First Search : DFS))"
date:   2020-02-16
excerpt: "비선형자료구조_그래프의 응용/다익스트라 알고리즘/ 최단경로 문제/헤밀턴 경로/ 헤밀턴 순회/NP 복잡도 "
category: [Algorithm]
layout: post
tag:
- Algorithm
comments: true
---



# 그래프 순회 Graph Traversals
그래프 순회: 그래프 탐색 Search 이라고도 불리우며 그래프의 **각 정점을 방문 하는 과정**을 말한다.         

* **DFS**: **깊이** 우선 탐색 Depth First Search       
* **BFS**: **너비** 우선 탐색 Breadth-First Search의 2가지 알고리즘이 있음     

![image](https://user-images.githubusercontent.com/76824611/122644655-4e3b5700-d151-11eb-8422-40215fba3fa7.png)

----


# 순회를 위한 그래프 준비
파이썬의 딕셔너리 자료형으로 구현    
![image](https://user-images.githubusercontent.com/76824611/122645272-94de8080-d154-11eb-8c87-8f38965a7ec5.png)


* **키**: 출발 노드    
* **값**: 도착 노드    
    
```python
graph = { 
 A: [B, C, D], 
 B: [E], 
 C: [E], 
 D: [], 
 E: [F, G], 
 F: [], 
 G: [C]
 } 
```
  
    
- 모든 정점들을 방문한 후 탐색을 종료함
- 순차적인 프로그램보다는 DFS 알고리즘을 재귀(recursive) 알고리즘으로 구현하는 것이 좋음
- 재귀 알고리즘으로 구현할 경우에는 스택(stack)을 사용함


----


# 깊이 우선 탐색(Depth First Search : DFS)
맹목적 탐색 기법 중 하나로, **자식** 노드를 확장할 수 있을 때까지 **깊이 우선**으로 탐색을 진행하는 방법     
일반적으로 BFS에 비해 더 널리 쓰임      
코딩 테스트 시에도 대부분의 그래프 탐색은 DFS로 구현하게 될 것임            
* 주로 **스택**으로 구현하거나 **재귀**로 구현     
  * 일반적으로 DFS는 스택으로 구현     
  * 재귀를 이용하면 좀더 간단하게 구현 가능(코테 시 더 많이 쓰임)       
* 이후에 살펴볼 백트래킹을 통해 뛰어난 효용을 보임           

---

## 재귀 구현

### 수도코드  
```python
DFS(G, v) 
 label v as discovered 
 for all directed edges from v to w that are in G.adjacentEdges(v) do 
  if vertex w is not labeled as discovered then 
   recursively call DFS(G, w)
```
(해석)        
* 정점 v 의 모든 인접 유향 Directed 간선들을 반복하라고 표기됨     

### Python 구현
```python
def recursive_dfs(v, discovered=[]):
 # 방문한 노드 기록
 discovered.append(v) 
 for w in graph[v]:
  #  현재 방문한 노드와 연결되어 있는 노드 (w)
  if w not in discovered:
   # w가 방문되지 않았을 경우에 아래 실행
   discovered = recursive_dfs(w, discovered) 
  return discovered
```

![image](https://user-images.githubusercontent.com/76824611/122658315-a3ee1e80-d1a6-11eb-9b1a-15dd4e2d5ce5.png)

**[탐색 결과]**     
```
>>> f'recursive dfs: {recursive_dfs(1)}'
'recursive dfs: [1, 2, 5, 6, 7, 3, 4]'
```

---

## 스택 구현

#### 스택을 이용한 반복 구조로 구현
(수도코드)
DFS-iterative(G, v) 
let S be a stack 
S.push(v) 
while S is not empty do 
v = S.pop() 
if v is not labeled as discovered then 
label v as discovered 
for all edges from v to w in G.adjacentEdges(v) do
 S.push(w)

(파이썬 코드로 구현)
def iterative_dfs(start_v):
discovered = [] 
stack = [start_v] 
while stack:
v = stack.pop()
if v not in discovered:
discovered.append(v) 
for w in graph[v]:
stack.append(w) 
return discovered
 
(탐색 결과)
>>> f'iterative dfs: {iterative_dfs(1)}'
'iterative dfs: [1, 4, 3, 5, 7, 6, 2]'

* 앞서 코드가 길고 빈틈없어 보이는 재귀 구현에 비해 우아함은 떨어지지만
* 좀 더 직관적 -> 이해하기는 훨씬 더 쉬움
* 실행 속도 또한 더 빠른 편

대부분의 경우 재귀 구현과 반복구현 동시구현 가능
* 서로 바꿔서 알고리즘을 구현할 자유롭게 바꿔가며 익숙해질 때까지 꾸준히 연습 필요   

[똑같은 DFS인데 순서가 다른 이유]
* 재귀 DFS: 사전식 순서 Lexicographical Order 로 방문
* 반복 DFS는 역순으로 방문
* 스택으로 구현: 가장 마지막에 삽입된 노드부터 꺼내서 반복해서

