---
title: "[020] Algorithm(그래프 순회 1_깊이 우선 탐색(Depth First Search : DFS))"
date:   2020-02-16
excerpt: "그래프 순회 Graph Traversals/깊이 우선 탐색(Depth First Search : DFS), DFS python 구현, DFS 재귀구현, DFS 스택구현, 수도코드. 스택과 재귀구현의 차이점 순회를 위한 그래프 준비,재귀 구현 "
category: [Algorithm]
layout: post
tag:
- Algorithm
comments: true
---


# 목차
- [그래프 순회 Graph Traversals](#그래프-순회-graph-traversals)
- [순회를 위한 그래프 준비](#순회를-위한-그래프 준비)
- [깊이 우선 탐색(Depth First Search : DFS)](#깊이-우선-탐색-depth-first-search---dfs-)
  * [재귀 구현](#재귀-구현)
    + [수도코드](#수도코드)
    + [Python 구현](#python-구현)
  * [스택 구현](#스택-구현)
    + [수도코드](#수도코드1)
    + [Python](#python)
    + [평가](#평가)


---


# 그래프 순회 Graph Traversals
그래프 순회: 그래프 탐색 Search 이라고도 불리우며 그래프의 **각 정점을 방문 하는 과정**을 말한다.         

* **DFS**: **깊이** 우선 탐색 Depth First Search       
* **BFS**: **너비** 우선 탐색 Breadth-First Search의 2가지 알고리즘이 있음     

![image](https://user-images.githubusercontent.com/76824611/122664272-7a031f00-d1db-11eb-96f7-fc5b2f96d3d1.png)

----
---


# 순회를 위한 그래프 준비
파이썬의 딕셔너리 자료형으로 구현    
![image](https://user-images.githubusercontent.com/76824611/122664276-7d96a600-d1db-11eb-9700-170dff7fd794.png)

* **키**: 출발 노드    
* **값**: 도착 노드    
    
```python
graph = { 
 A: [B, C, D], 
 B: [E], 
 C: [E], 
 D: [], 
 E: [F, G], 
 F: [], 
 G: [C]
 } 
```
  
    
- 모든 정점들을 방문한 후 탐색을 종료함
- 순차적인 프로그램보다는 DFS 알고리즘을 재귀(recursive) 알고리즘으로 구현하는 것이 좋음
- 재귀 알고리즘으로 구현할 경우에는 스택(stack)을 사용함


----


# 깊이 우선 탐색(Depth First Search : DFS)
맹목적 탐색 기법 중 하나로, **자식** 노드를 확장할 수 있을 때까지 **깊이 우선**으로 탐색을 진행하는 방법     
일반적으로 BFS에 비해 더 널리 쓰임      
코딩 테스트 시에도 대부분의 그래프 탐색은 DFS로 구현하게 될 것임            
* 주로 **스택**으로 구현하거나 **재귀**로 구현     
  * 일반적으로 DFS는 스택으로 구현     
  * 재귀를 이용하면 좀더 간단하게 구현 가능(코테 시 더 많이 쓰임)       
* 이후에 살펴볼 백트래킹을 통해 뛰어난 효용을 보임           

---

## 재귀 구현

### 수도코드  
```python
DFS(G, v) 
 label v as discovered 
 for all directed edges from v to w that are in G.adjacentEdges(v) do 
  if vertex w is not labeled as discovered then 
   recursively call DFS(G, w)
```
(해석)        
* 정점 v 의 모든 인접 유향 Directed 간선들을 반복하라고 표기됨     

### Python 구현
```python
def recursive_dfs(v, discovered=[]):
 # 방문한 노드 기록
 discovered.append(v) 
 for w in graph[v]:
  #  현재 방문한 노드와 연결되어 있는 노드 (w)
  if w not in discovered:
   # w가 방문되지 않았을 경우에 아래 실행
   discovered = recursive_dfs(w, discovered) 
  return discovered
```

![image](https://user-images.githubusercontent.com/76824611/122664342-cb131300-d1db-11eb-9656-a25f7cc90c99.png)



**[탐색 결과]**        
```
>>> f'recursive dfs: {recursive_dfs(1)}'
'recursive dfs: [A, B, E, F, G, C, D]'
```

---

## 스택 구현

### 수도코드
```python
DFS-iterative(G, v) 
    let S be a stack 
    S.push(v) 
    while S is not empty do 
        v = S.pop() 
        if v is not labeled as discovered then 
            label v as discovered 
            for all edges from v to w in G.adjacentEdges(v) do
                S.push(w)
```

### Python
```python
def iterative_dfs(start_v):
    discovered = [] 
    stack = [start_v] 
    while stack:
        v = stack.pop()
        if v not in discovered:
            discovered.append(v) 
            for w in graph[v]:
                stack.append(w) 
        return discovered
``` 

![image](https://user-images.githubusercontent.com/76824611/122664346-cf3f3080-d1db-11eb-8782-e40e49cda8b7.png)


**[탐색 결과]**    
``` 
>>> f'iterative dfs: {iterative_dfs(1)}'
'iterative dfs: [A,D,C,E,G,F,B]'
``` 

### 평가
* 앞서 코드가 길고 빈틈없어 보이는 재귀 구현에 비해 우아함은 떨어지지만      
* 좀 더 **직관적** -> 이해하기는 훨씬 더 쉬움     
* 실행 속도 또한 더 빠른 편         
 
대부분의 경우 재귀 구현과 반복구현 동시구현 가능     
* 서로 바꿔서 알고리즘을 구현할 자유롭게 바꿔가며 익숙해질 때까지 꾸준히 연습 필요   

**[똑같은 DFS인데 순서가 다른 이유]**   
* **재귀 DFS**: 사전식 순서 Lexicographical Order로 방문   
* 반복 DFS는 역순으로 방문   
* 스택으로 구현: 가장 마지막에 삽입된 노드부터 꺼내서 반복해서   



---
----


[learn BFS]
