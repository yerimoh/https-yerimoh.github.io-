---
title: "[1021] (파이썬)leet code_819. Most Common Word"
date:   2020-01-9
excerpt: "팰린드롬, 회문"
category: [Coding test]
layout: post
tag:
- Coding test
comments: true
---

# 목차
- [유효한 팰린드롬](#유효한-팰린드롬)
  * [문제](#문제)
- ['팰린드롬' 이란?](#-팰린드롬--이란-)
- [**풀이과정**](#--풀이과정--)
  * [1. 전처리](#1-전처리)
  * [2. 팰린드롬 판별](#2--팰린드롬-판별)
  * [PLUS) 데크 자료형을 이용한 최적화](#plus--데크-자료형을-이용한-최적화)
  * [3. 문제 적용](#3--문제-적용)
- [전체 코드](#전체-코드)






-----

👀, 🤷‍♀️ , 📜    
이 아이콘들을 누르시면 코드, 개념 부가 설명을 보실 수 있습니다:)

------





# 가장 흔한 단어
난이도| ★★
[리트코드 819. Most Common Word](https://leetcode.com/problems/most-common-word/)


## 문제

Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.

The words in paragraph are case-insensitive and the answer should be returned in lowercase.

 




**Example1:**  
```
Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]
Output: "ball"
Explanation: 
"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.
```


**Example1:**  
```
Input: paragraph = "a.", banned = []
Output: "a"
```


**[제한]**    
* 1 <= paragraph.length <= 1000     
* paragraph consists of English letters, space ' ', or one of the symbols: "!?',;.".    
* 0 <= banned.length <= 100    
* 1 <= banned[i].length <= 10    
* banned[i] consists of only lowercase English letters.    



---
----


# 풀이


들어가기 전 알아 둘 개념     
* 리스트 컴프리헨션     
* Counter 객체 사용       
* 
입력값에는 대소문자가 섞여 있으며 쉼표 등 구두점이 존재한다. 따라서 데이터 클렌징
Data Cleansing 이라 부르는 입력값에 대한 전처리 Preprocessing 작업이 필요하다. 좀 더 편리 하게 처리하기 위해 정규식을 섞어 쓰면 다음과 같이 처리할 수 있다.
words = [word for word in re.sub(r'[^\w]', ' ', paragraph) .lower().split() if word not in banned]
정규식에서 \w 는 단어 문자 Word Character 를 뜻하며, ^ 은 not을 의미한다. 따라서 위 정규 식은 단어 문자가 아닌 모든 문자를 공백으로 치환 Substitute 하는 역할을 한다.
아울러 리스트 컴프리헨션의 조건절에는 banned 에 포함되지 않은 단어만을 대상으로 한다. 따라서 words 에는 소문자, 구두점을 제외하고 banned 를 제외한 단어 목록이 저장된 다. 이제 다음과 같이 각 단어의 개수를 헤아려 보자.

counts = collections.defaultdict(int) for word in words: "
counts[word] += 1
여기서 개수를 담아두는 변수는 딕셔너리를 사용하며 defaultdict() 를 사용해 int 기본 값이 자동으로 부여되게 했다. 따라서 여기서는 키 존재 유무를 확인할 필요 없이 즉시
counts[word] += 1 을 수행할 수 있다.
return max(counts, key=counts.get)
딕셔너리 변수인 counts 에서 값이 가장 큰 키를 가져온다. 즉 수학에서 argmax와 동일 하다. 그런데 파이썬의 기본 타입은 argmax를 지원하지 않는다. 과학 계산 라이브러리인 넘파이 NumPy 는 이를 잘 지원하지만, 아쉽게도 코딩 테스트에서는 어떠한 외부 라이브 러리도 사용할 수 없다. 따라서 이처럼 max() 함수에 key 를 지정해 argmax를 간접적으로 추출할 수 있다. 개수를 처리하는 부분은 Counter 모듈을 사용하면 좀 더 깔끔하게 처리할 수 있다.
다음 코드는 words 에서 가장 흔하게 등장하는 단어의 첫 번째 값을 most_common(1) 으로 추출한다. 문제의 입력값에서는 [('ball', 2)] 가 되며, 이 값의 [0][0] 을 추출해서 최종 적으로 첫 번째 인덱스의 키를 추출하게 된다. 이렇게 추출한 키인 ball 은 가장 흔한 단어가 되므로, 이제 이 값을 리턴한다.
counts = collections.Counter(words) return counts.most_common(1)[0][0]
이처럼 Counter 객체를 이용해 비교적 간단히 구현할 수 있었으며, 모두 정리하면 전체 코드는 다음과 같다.
def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
words = [word for word in re.sub(r'[^\w]', ' ', paragraph) .lower().split() if word not in banned]
counts = collections.Counter(words) # 가장 흔하게 등장하는 단어의 첫 번째 인덱스 리턴 return counts.most_common(1)[0][0]




-------





# **풀이과정** 
이 문제는 크게 두가지 과정을 거친다.       
1️⃣ 전처리: 모두 소문자로 바꾸고 영문자와 숫자만 골라내기      
2️⃣ 골라낸 것들의 팰린드롬 판별하기      
3️⃣ 만든 팰린드롬을 문제에 적용하기   


----

## 1. 전처리

먼저 영문자와 숫자만 골라낸 후,    
골라낸 것들을 소문자로 바꿔야 한다.      

영문자와 숫자와 골라내는 매서드는 ```바꿀 것.isalnum()```이다.     
이건 **is**+**al**phabet+**num**ber라고 기억해두면 좋다.   
생각보다 많이 쓰이니까 기억해두자.         

그리고 골라낸 것들을 소문자로 바꾸는 매서드는 ```바꿀 것.lower()```이다.    

즉 이를 이용하여 코드를 짜보면

```python
def isPalindrome(self, s: str) -> bool:
	str = [] # 소문자인 알파벳과 숫자만 넣을 곳
	for i in s: # 하나하나 둘러보자
	    if i.isalnum(): # 숫자와 골라내는 매서드
		str.append(i.lower()) # 소문자로 바꾸는 매서드
```

![pal1](https://user-images.githubusercontent.com/76824611/147919817-f63e1468-dd24-432a-9f83-061c1ccfc09e.gif)

<details>
<summary>📜 과정 자세히 보기</summary>
<div markdown="1">
	
<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/CffT5uColMhSEY" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"></div>
</div>	
	
</div>
</details>  	
	
	
	
-----

## 2. 팰린드롬 판별
먼저 넣은 str을 한번씩 봐야된다.    
![image](https://user-images.githubusercontent.com/76824611/147916783-4c7b40d3-9e67-4f46-b340-4217e2e36687.png)
여기에 앞 뒤를 하나씩 꺼내서 보는 것 이다.     

앞에 것을 ```pop(0)```을 통해 꺼내고 뒤의 것을 ```pop()```을 통해 꺼낸다.     
그리고 이 두개를 비교한다.      

그래서 계속 같으면 True 다르면 False를 return하면 된다.       


  
```python
while len(str) > 1:
    if str.pop(0) != str.pop():
	return False
return True
```
  
![pal2](https://user-images.githubusercontent.com/76824611/147919821-0482102d-6c2f-4e74-9f23-f6a8c6cbc1d3.gif)


<details>
<summary>📜 과정 자세히 보기</summary>
<div markdown="1">	
	
<div align="center">
<iframe src="//www.slideshare.net/slideshow/embed_code/key/ClgoatkPWmoD8u" width="595" height="485" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> <div style="margin-bottom:5px"></div>
</div>

	
</div>
</details>  
	
----

## PLUS) 데크 자료형을 이용한 최적화
[데크란?](https://yerimoh.github.io/Algo9/)

전체 과정을 위와 똑같다


```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        str: Deque = collections.deque() # 데크선언
        for i in s:
            if i.isalnum():
                str.append(i.lower())
        while len(str) > 1:
            if str.popleft() != str.pop():
                return False
        return True
```




-----

## 3. 문제 적용
위에서 만든 팰린드롬 함수를 문제에 맞게 적용해보면 된다   

```python
while True:
    instr = input()
    if instr == '0':
        break
    if isPalindrome(instr)==True:
        print("yes")
    else:
        print("no")
```



------
----


# 전체 코드

위를 구현한 전체 코드는 다음과 같다

데크를 쓰지 않았을 때

```python
def pal(instr):
    strs = []
    for char in instr:
        if char.isalnum(): # 알파벳, 숫자 골라내기
            strs.append(char.lower())
    
    # 이제 각 줄의 strs가 만들어짐
    
    
    else:
        while len(strs)>1:
            if strs.pop(0) != strs.pop():
                return False
        return True
    

while True:
    instr = input()
    if instr == '0':
        break
    if pal(instr)==True:
        print("yes")
    else:
        print("no")

```


-----


데크를 썼을 때 


```python

from collections import deque

def pal(instr):
    strs = deque()
    for char in instr:
        if char.isalnum(): # 알파벳, 숫자 골라내기
            strs.append(char.lower())
    
    # 이제 각 줄의 strs가 만들어짐
    
    
    else:
        while len(strs)>1:
            if strs.popleft() != strs.pop():
                return False
        return True
    

while True:
    instr = input()
    if instr == '0':
        break
    if pal(instr)==True:
        print("yes")
    else:
        print("no")

```







