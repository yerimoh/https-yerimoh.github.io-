---
title: "[011] Algorithm(탐색 알고리즘 2_이진탐색(binary search)/bisect 모듈)"
date:   2020-03-3
excerpt: "이진탐색(binary search),bisect 모듈, 수도코드, 원리, 과정, 파이썬 이진구현(재귀, 반복, 이진검색 모듈, 이진검색을 사용하지 않는 index풀이), 자바구현"
category: [Algorithm]
layout: post
tag:
- Algorithm
comments: true
---

#### BST추가해라

# 이진 탐색 Binary Search



## 정의
**정렬된 배열**에서 **타겟을 찾는** 검색 알고리즘              
* O($$log_{2}n$$)알고리즘    
 * 대표적인 로그 시간 알고리즘    
 * 로그는  1억 개의 아이템도 단 27번이면 모두 찾아낼 정도로 설능이 좋음      
 ```python
 >>> import math 
 >>> math.log2(100000000)
 26.575424759098897
 ```
* [이진 탐색 트리 Binary Search Tree (이하 BST)]()와도 유사한 점이 많음    
 *  BST(Binary Search Tree): 이진 탐색 트리가 정렬된 구조를 저장하고 탐색하는 **‘자료구조’**        
 *  이진 검색(Binary Search): 정렬된 배열에서 값을 찾아내는 **‘알고리즘’** 자체를 지칭         
 * [주의] 같은 Binary Search가 들어가도 둘은 다른 개념이므로 혼동하지 않게 주의    



## 알고리즘 개요
* 정렬된 배열에서 **가운데 값**과 찾고자 하는 원소를 비교    
  * 찾는 값이 더 **작으면**: 배열의 **작은 쪽**에서 다시 **가운데 값**과 비교    
  * 찾는 값이 더 **크면**: 배열의 **큰 쪽**에서 다시 **가운데 값**과 비교    
* 찾을 때까지 같은 방법을 계속 실행함    

ex)  1부터 100까지의 숫자 중 79를 찾는 과정    
① 중간값 50부터 탐색을 시작       
①-② 79는 50보다 크므로 왼쪽 포인터를 오른쪽으로 이동    

② 그다음 중간값 75로 탐색 시작       
②-② 79는 75보다 크므로 마찬가지로 왼쪽 포인터를 오른쪽으로 이동        
 
③ 그 다음 중간값 87로 탐색 시작       
③-② 79는 87보다는 작으므로 이번에는 오른쪽 포인터를 왼쪽으로 이동      
...
⑥ 77=77       
-> 이런 식으로 점점 범위를 좁혀 나가면 $$log_{2}100$$ 즉, 7번 이내에 무조건 숫자를 맞출 수 있음    
![image](https://user-images.githubusercontent.com/76824611/120940501-8eb1d280-c758-11eb-8104-83fba26c6d9f.png)
```python
>>> math.log2(100)
6.643856189774724
```

## 수도코드
![image](https://user-images.githubusercontent.com/76824611/120940567-e5b7a780-c758-11eb-936b-0d67120198e8.png)

정렬된 nums 를 입력받아 이진 검색으로 target 에 해당하는 인덱스를 찾아라.     
•입력   
nums = [-1,0,3,5,9,12], target = 9    
•출력    
4    

## 구현(파이썬)
ex) [리트코드 704. Binary Search](https://leetcode.com/problems/binary-search/)

### 재귀 구현
```python
def search(self, nums: List[int], target: int) -> int:
  def binary_search(left, right):
    if left <= right:
      mid = (left + right) // 2
      
      if nums[mid] < target:
        return binary_search(mid + 1, right) 
      elif nums[mid] > target:
        return binary_search(left, mid - 1)
      else:
        return mid 
    else:
      return -1
  
  return binary_search(0, len(nums) - 1)
```
+) 명시적으로 표현하기 위해 return을 print로 바꿈

![22](https://user-images.githubusercontent.com/76824611/120941211-662bd780-c75c-11eb-8022-ce28a991109e.gif)


**[주의]**
파이썬 재귀 제한     
파이썬에는 재귀 호출에 대한 호출 횟수 제한이 있으며 기본 값은 1,000으로 설정되어 있다.     
```python
>>> sys.getrecursionlimit()
1000
```

### 반복 구현
* 조금 더 직관적    
* 재귀보단 덜 우아함    
```python
def search(self, nums: List[int], target: int) -> int:
  left, right = 0, len(nums) - 1 
  while left <= right:
    mid = (left + right) // 2
    if nums[mid] < target:
      left = mid + 1 
    elif nums[mid] > target:
      right = mid - 1 
    else:
      return mid 
   return -1
```
![33](https://user-images.githubusercontent.com/76824611/120941511-11895c00-c75e-11eb-9245-1e393d0231b3.gif)

### 이진 검색 모듈 bisect
파이썬에서는 이진 검색을 직접 구현할 필요가 없음     
이진 검색 알고리즘을 지원하는 ```bisect 모듈```을 기본으로 제공.      
* 여러 가지 예외 처리를 포함한 이진 검색 알고리즘이 깔끔하게 모듈 형태로 구현되어 있음     
* 이 모듈을 이용하면 이진 검색을 파이썬다운 방식으로 다음과 같이 좀 더 간단히 풀이 가능     

**[bisect 모듈]**    
출처: [Lib/bisect.py](https://github.com/python/cpython/blob/3.9/Lib/bisect.py)       
(기능 크게 2개로 나뉨)    
**[1]**       
주어진 list와  target이 있을 때, **target**이 위치해야 할 **인덱스**를 구하는 함수     

```bisect.bisect_left(a, x, lo=0, hi=len(list))```         
* **오름차 순으로 정렬**된 순서를 유지하도록 list에  target을 삽입할 위치를 찾음     
* ```a```: list(num)    
* ```x```: target     
* 매개 변수 ```lo``` 와 ```hi```는 고려해야 할 리스트의 부분집합을 지정하는 데 사용    
  * ```lo= ```: list 범위중 시작 위치       
  * ```hi= ```: list 범위중 끝 위치     
  * 기본적으로 **전체** 리스트가 사용     
즉, ```a```(list)값이 

* target이 list에 이미 있으면, 삽입 위치는 기존 항목 **앞(왼쪽)**.        
* 반환 값은 list.insert()의 첫 번째 매개 변수로 사용하기에 적합     
* 반환된 삽입 위치 i는 배열 a를 이분하여,     
  * 왼쪽은 all(val < x for val in a[lo:i])    
  * 오른쪽은 all(val >= x for val in a[i:hi])이 되도록 만듦      
```python  
list = [-1,0,3,5,9,12], target = 9  
bisect.bisect_left(list, target)
# 출력 
# 4

bisect.bisect_left(list, target, lo=1, hi=3)
# list[1]<= in_list < list[3]
# in_list = [0,3]
# list = in_list
# 출력 
# -1 (target이 없음)

```

```bisect.bisect_right(list, target, lo=0, hi=len(list))```     
```bisect = bisect_right```      
* **내림차순으로 정렬**된 순서를 유지하도록 list에  target을 삽입할 위치를 찾음      
* 매개 변수 ```lo``` 와 ```hi```는 고려해야 할 리스트의 부분집합을 지정하는 데 사용   
  * 기본적으로 전체 리스트가 사용     
* target이 list에 이미 있으면, 삽입 위치는 기존 항목 **뒤(오른쪽)**.        
* 반환 값은 list.insert()의 첫 번째 매개 변수로 사용하기에 적합     
* 반환된 삽입 위치 i는 배열 a를 이분하여,     
  * 왼쪽은 all(val > x for val in a[lo:i])    
  * 오른쪽은 all(val <= x for val in a[i:hi])이 되도록 만듦      
```python  
list  = [12,9,6,3,0,-1], target = 9  
bisect.bisect_left(list, target)
# 출력 
# 1
```


**[2]**      
같은 조건에서 값 target을 올바른 위치에 삽입하는 함수

bisect.insort_left(a, x, lo=0, hi=len(a))
a에 x를 정렬된 순서로 삽입합니다. a가 이미 정렬되었다고 가정할 때 a.insert(bisect.bisect_left(a, x, lo, hi), x)와 동등합니다. O(log n) 검색이 느린 O(n) 삽입 단계에 가려짐에 유념하십시오.

bisect.insort_right(a, x, lo=0, hi=len(a))
bisect.insort(a, x, lo=0, hi=len(a))
insort_left()와 비슷하지만, a에 x를 x의 기존 항목 다음에 삽입합니다.
```python
def search(self, nums: List[int], target: int) -> int:
index = bisect.bisect_left(nums, target)
if index < len(nums) and nums[index] == target:
return index 
else:
return -1
```
### 이진 검색을 사용하지 않는 index 구현  
