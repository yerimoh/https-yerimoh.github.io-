---
title: "[014] Computer Network: TCP 프로토콜"
date:   2021-02-22
excerpt: "TCP/IP 프로토콜의 계층적인 구조, TCP 필요성/ TCP 헤더 구조(TCP 헤더의 필드, 헤더의 플래그 비트,혼잡 제어,캡슐화)/ 포트 번호 "
category: [CS basic]
layout: post
tag:
- CS basic
order: 0

comments: true
---


# 목차
- [**TCP 프로토콜**](#**tcp-프로토콜**)
  * [TCP/IP 프로토콜의 계층적인 구조](#tcp-ip-프로토콜의-계층적인-구조)
  * [TCP 필요성](#tcp-필요성)
  * [TCP의 역할](#tcp의-역할)
- [**TCP 헤더 구조**](#**tcp-헤더-구조**)
  * [TCP 헤더의 필드](#tcp-헤더의-필드)
  * [TCP 헤더의 플래그 비트 flags](#tcp-헤더의-플래- 비트-flags)
  * [혼잡 제어](#혼잡-제어)
  * [캡슐화](#캡슐화)
- [**포트 번호**](#**포트-번호**)


----

# **TCP 프로토콜**
**TCP(Transmission Control Protocol)**    
IP 프로토콜 위에서 연결형 서비스를 지원하는 전송 계층 프로토콜       
인터넷 환경에서 기본으로 사용한다.        
* 연결형 서비스를 제공한다.    
* 전이중 Full Duplex 방식의 양방향 가상 회선을 제공한다.  
* 신뢰성 있는 데이터 전송을 보장한다.    


## TCP/IP 프로토콜의 계층적인 구조
인터넷 환경에서 사용하는 TCP/IP 프로토콜의 계층적인 구조임    
      

![image](https://user-images.githubusercontent.com/76824611/165270696-c3c07fba-4800-45c0-8d09-107ed7e8d97a.png)


**[응용 계층]**      
* 전송 계층 프로토콜인 TCP와 UDP 위에는 세션 계층, 표현 계층, 응용 계층의 기능을 지원하는 다양한 응용 프로그램이 존재한다.    
* 응용 프로그램의 종류: 네임서버 기능(호스트의 이름과 주소를 변환), 파일 전송 기능, 메일 송수신 기능 등은 일반 사용자가 가장 많이 이용하는 인터넷 서비스 등       


**[전송 계층]**    
* 통신을 활성화하기 위한 계층   
* 전송 계층 프로 토콜은 **운영 체제의 내부 기능으로 구현**된다.      
➡ 이 서비스를 사용하려면 상위 계층에서 **시스템 콜**이라는 프로그램 호출 방식을 이용해야 한다.     
* IP 프로토콜 위에서 실행되는 전송 계층 프로토콜은 서비스의 유형에 따라 두 종류로 구분한다.      
  * **TCP**: 연결형 서비스를 지원하는 프로토콜     
  * **UDP**: 비연결형 서비스를 지원하는 프로토콜  
* 응용 프로그램이 해당 응용 환경에 적합한 기능을 지원 하기 위해 연결형 서비스가 필요한지, 비연결형 서비스가 필요한지를 판단해 TCP와 UDP를 선택한다.     
* TCP나 UDP를 선택할 때는 단순히 신뢰성이나 연결 유무의 차이뿐 아니라, 이러한 차이가 응용 프로그램의 구축에 어떤 영향을 끼치는지 이해해야 한다.    


**[네트워크 계층]**     
* **[IP](https://yerimoh.github.io/CN011/)**: 인터넷에서 네트워크 계층의 기능을 제공하는 프로토콜    
* 여러개의 노드를 거칠때마다 **경로를 찾아주는 역할**을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한 기능적, 절차적 수단을 제공한다.     
* 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능       
    

**[네트워크 접속 계층]**          
* 네트워크 계층 아래에는 데이터 링크 계층을 지원하는 X.25, [이더넷](https://yerimoh.github.io/CN09/), 위성 통신 등 다양한 종류의 **네트워크 인터페이스**가 존재한다.       


➕ **TCP의 전송방식**         
* TCP는 데이터를 세그먼트 Segment 라는 **블록 단위로 분할해 전송**한다.      
* 전송되는 블록의 크기는 네트워크 부하 정도, 윈도우 크기 등의 영향을 받으며, **가변 크기**를 지원한다.     
* TCP는 세그먼트를 하나의 단위로 간주하여 **순서 번호를 관리하지 않는다**.      
* 대신 세그먼트에 실려 전송되는 **데이터의 바이트 개수를 순서 번호에 반영**한다.     


----



## TCP 필요성
**연결 지향 전송**        
➡ 송신자와 수신자가 존재하며 송신될 데이터와 그 순서를 해석하는 방법이 존재함을 의미    

**End-to-End 전송**    
➡ 데이터는 원상태로 유지됨을 신뢰할 수 있어야 한다.     

**신뢰성 있는 전송**      
➡ 모든 데이터가 수신이 확인되지 않으면 그 데이터는 재전송되어야 한다.  
 
**프로세스간 통신**    
➡ 프로세스간의 통신 기능을 제공    



----

## TCP의 역할   
[더 알아보기](https://yerimoh.github.io/CN013/)      

**[RFC 793 기준]**   

**Basic Data Transfer (기본적인 데이터 전송)**      
➡ TCP는 다양한 구현을 통해 데이터를 연속 바이트스트림으로 송신할 수 있다.     


**Reliability (신뢰성)**    
➡ TCP는 인터넷 통신 시스템에 의해 손상, 손실, 복제 또는 순서가 잘못된 데이터로부터 복구되야 한다.   

**Flow Control(흐름제어)**    
➡ TCP는 수신자가 데이터 양을 제어할 수 있는 수단을 제공한다.     

**Multiplexing(멀티플렉스)**   
➡ 호스트는 단일 소켓상에서 다중 통신을 수행할 수 있다.    


**Connections(연결)**    
➡ 두개의 호스트는 three-way handshake 절차를 통해 하나의 TCP 연결을 구성한다.    

**Precedence and Security(우선 순위 및 보안)**    
➡ 보안 및 우선 순위를 나타낼 수 있다.     


----
----


# **TCP 헤더 구조**
TCP의 세그먼트는 아래와 같은 헤더 구조로 시작하고, 전송 데이터가 뒤따른다.    
* 그림 상단의 숫자는 비트 수이다.      
* Options와 Padding은 생략 가능      
  * **Options 필드**: 다양한 종류의 부가 정보를 전달하는 데 사용하며, 최대 40바이트의 크기를 지원        
  * **Padding 필드**: 헤더의 크기를 4바이트 단위로 맞추려고 사용      
* TCP 헤더의 최소 크기는 20바이트       

![image](https://user-images.githubusercontent.com/76824611/165278705-caa42756-ffdd-41bb-8169-e2f8400c8525.png)

---

## TCP 헤더의 필드
TCP 헤더 TCP Header 는 중간에 위치한 여덟 개의 플래그 비트를 비롯해 제법 많은 필드를 사용 하므로,   
데이터의 전송 과정이 UDP보다 복잡하다. 

**[Source Port/Destination Port(송신 포트/수신 포트)]**     
* 16bits   
* TCP로 연결되는 가상 회선 양단의 송수신(통신) 프로세스에 할당된 네트워크 포트 주소이다.      
* 인터넷 환경에서는 호스트주소와 고유주소가 필요하다.     
    * **호스트 주소**: 통신을 원하는 프로세스가 실행됨(IP 프로토콜에서 정의된 호스트의 IP 주소를 사용)       
    * **프로세스의 고유 주소**: 호스트 **내부**에서 다른 프로세스와 구분할 수 있게 함.(프로세스에 할당되는 네트워크 자원을 포트 Port 라 하는데, 포트를 구분하기 위한 주소가 포트 번호)         
           * **Source Port**: 송신 프로세스의 포트 번호     
           * **Destination Port**: 수신 프로 세스의 포트 번호        
           * 참고로, 포트 번호는 TCP와 UDP가 별도의 주소 공간을 갖기 때문에 **같은 번호를 독립적으로 사용 가능**           


**[Sequence Number(순서 번호)]**      
* 32bits    
* 송신 프로세스가 지정하는 순서 번호이다.     
* 세그먼트 전송 과정에서 전송되는 바이트의 수를 기준으로 증가한다.    
* 즉, TCP에서는 전송 데이터의 각 바이트마다 **순서 번호가 존재**한다.     
* 크기가 32비트인 필드로 표시할 수 있고, 최대 범위가 $$2^{32}$$ 개로 충분히 크므로 순서 번호가 중복될 염려는 없다.     
* 송신 프로세스가 **최초 데이터**를 전송할 때는 **임의의 순서 번호를 선택해 전송**한다.     
➡ 이는 전송 연결이 예기치 않은 이유로 끊겼을 때 순서 번호가 혼선되는 것을 방지하기 위함이다.       
* 해석    
     * SYN flag가 설정된 경우(1): 초기 시퀀스 번호       
     * SYN flag가 지워진 경우(0): 현재 세션에 대한 세그먼트의 첫번쨰 데이터 바이트의 누적 시퀀스 번호   



**[Acknowledgement Number(응답 번호)]**     
* 수신 프로세스가 제대로 수신한 바이트의 수를 응답하기 위해 사용한다.     
* 필드 값은 ACK 플래그 비트가 지정된 경우에만 유효하며, **다음에 수신을 기대하는 데이터의 순서 번호를 표시**한다.    
* ACK 응답을 받은 송신 프로세스는 Acknowledgement Number-1까지의 모든 데이터가 올바로 전송되었음을 확인할 수 있다.     
* 연결 설정이나 연결 해제처럼 데이터 세그먼트가 없는 경우에도 순서 번호가 1씩 증가한다는 점에 주의한다.


**[Data Offset(데이터 옵셋)]**      
* TCP 세그먼트가 시작되는 위치를 기준으로 **데이터의 시작 위치**를 나타내므로 **TCP 헤더의 크기가 된다.**      
* 32비트 워드 단위로 표시된다. ➡  5words ~ 15words 20bytes~60bytes
     


**[Reserved(예약)]**    
* 예약 필드이다.   
* 향후 프로토콜 수정 작업을 대비, 정의되지 않은 3bits를 포함   
* 0으로 설정    



**[Window(윈도우)]**     
* 16bits    
* 수신측에서 송신측에 보내는 수신버퍼의 여유공간 크기, 송신측에서 흐름제어를 수행     
* 슬라이딩 윈도우 프로토콜에서 수신 윈도우의 버퍼 크기를 지정하려고 사용하며, 수신 프로세스가 수신할 수 있는 바이트의 수를 표시한다.      
* 수신 프로세스의 버퍼 용량 초과 등으로 인해 데이터를 **더 이상 수신할 수 없으면 Window 필드 값을 0**으로 지정한다. 이경우에 송신 프로세스는 데이터를 더 전송하면 안 된다.      


**[Checksum(체크섬)]**        
* 16bits       
* TCP 세그먼트에 포함되는 프로토콜 헤더와 데이터 모두에 대한 변형 오류를 검출하려고 사용한다. IP 프로토콜에서 사용하는 오류 검출 알고리즘을 사용한다.    
* [더 알아보기](https://yerimoh.github.io/CN011/#%EA%B8%B0%ED%83%80-%ED%95%84%EB%93%9C)       


**[Urgent Pointer(긴급 포인터)]**     
* 16bits    
* 긴급 데이터의 위치값      
* 긴급 데이터를 처리하기 위한 것으로, URG 플래그 비트가 지정된 경우에 유효하다.      
* 이 필드를 사용해 송신 프로세스가 **긴급히 처리하려는 데이터를 전송**할수 있다.     
* 예를 들어, Sequence Number =2,000, Urgent Pointer =100으로 지정한 패킷을 전송하면 순서 번호 2,000~2,099번의 데이터는 긴급 데이터로 전송되고, 2,100번 이후는 다시 정상 데이터로 전송된다.      


----


## TCP 헤더의 플래그 비트 flags      
9bits      
TCP 헤더에는 플래그 비트가 8개 정의되어 있다.        
* 처음 2(3)개 비트는 혼잡 제어 용도로 사용됨        
   * **NS** :  ECN-nonce 은폐보호 RFC3540 추가   
   * **CWR** : 혼잡제어 메커니즘에 응답했음 RFC3168 추가   
   * **ECE** : RFC3168 추가     
* 나머지 6개 필드는 값이 **1**이면 다음과 같은 의미를 갖는다.      

**[URG]**     
* Urgent Pointer 필드가 유효한지(wnddygkswl)를 나타낸다.      
* 이 기능은 수신 프로세스의 응용 계층에 긴급 데이터가 도착했음을 알리는 것으로, 데이터가 응용 계층에 전달되기 전에 긴급 데이터가 왔음을 미리 알려주어 대비할 수 있게 한다.       
* 수신 프로세스는 Urgent Pointer 값을 읽어보고 **얼마나 많은 긴급 데이터가 오는지** 알 수 있다.    
    


**[ACK]**    
* Acknowledgment Number 필드가 유효한지를 나타낸다.      
* 정상적인 피기배킹 방식의 양방향 통신 환경에서, 양단 프로세스가 **쉬지 않고 데이터를 전송**한다고 가정하면,   
 최초 연결 설정 과정에서 전송되는 **첫 번째 세그먼트를 제외한 모든 세그먼트의 ACK 비트가 1**로 지정된다.


**[PSH]**      
* 현재 세그먼트에 포함된 데이터를 **상위 계층에 즉시 전달**하도록 지시할 때 사용           
* 수신 프로세스로부터 PSH 세그먼트에 대한 **응답 프레임이 도착**하면,    
➡ 프레임의 Acknowledgement Number 필드에 표시한 숫자까지의 **모든 데이터**가 **상대 프로세스의 상위 계층에 전달**되었음을 의미    
* 또한 수신 프로세스의 TCP 계층에 버퍼링된 데이터를 **즉시** 상위 계층에 **전송**함으로써 **전송 지연이 감소**되는 효과를 얻을 수 있다.         


**[RST]**    
* **연결의 리셋**이나 유효하지 않은 세그먼트에 대한 응답용으로 사용한다.      
* 송신 프로세스가 전송을 마쳤으나 수신 프로세스에 아직 도착하지 못한 세그먼트, 혹은 수신 프로세스가 아직 긍정 응답하지 않은 세그먼트는 연결이 재설정되었을 때 재전송되어야 한다.       
* TCP 세그먼트 내의 데이터가 최대한 빨리 응용 프로그램에 전달되야 함을 의미    


**[SYN]**    
* **연결 설정 요구**를 의미하는 플래그 비트이므로 가상 회선 연결을 설정하는 과정에서 사용한다.      
* **시퀀스 번호를 동기화**      



**[FIN]**     
* 송신측의 마지막 패킷      
* 한쪽 프로세스에서 더는 전송할 데이터가 없어 연결을 종료하고 싶다는 의사 표시를 상대방에게 알리려고 사용함     
* 현재 전송 과정에 있는 데이터는 계속 처리할 수 있으며, 상대편 프로세스의 데이터 전송에 장애가 발생하지 않는다. 따라서 연결 해제는 양쪽 프로세스 모두가 FIN 플래그를 전송해야 완료된다.     


----

## 혼잡 제어
**ECN (Explicit Congestion Notification)**: 라우터가 송신 프로세스에 명시적으로 **혼잡 발생을 알려주어** **송신 프로세스 스스로 트래픽을 완화**하는 기술이다.        

TCP는 ECN 기능을 지원하기 위해 2개의 필드 정의    
* CWR 필드        
* ECE 필드     



**[CWR(Congestion Window Reduced)]**     
* ECE 비트를 수신한 송신 프로세스가 **전송 윈도우 크기를 줄였음을 통지**하는 것이 목적      
* 더 이상의 **ECE를 전송하지 말라**는 의미이다.      


**[ECE(Explicit Congestion Notification Echo)]**      
* ECN-Echo로도 약칭됨      
* 네트워크 **트래픽이 많아질 때**, 라우터가 **송신** 프로세스에 명시적으로 **혼잡**을 알리려고 사용한다.     
* **주의**: 송신 프로세스에 ~~직접 전달~~하지 않고, IP 헤더의 **ECN 필드**에 CE 값을 지정하여 **간접적**으로 수신 프로세스에 **알려준 후**에 수신 프로세스의 중개 **Echo 를 거쳐 송신 프로세스에 통지**된다는 점이다.            
* ECE를 수신한 송신 프로세스는 네트워크 부하를 줄이기 위해 전송 윈도우 크기를 줄인다.      
* 라우터가 IP 프로토콜을 이용하여 수신 프로세스의 중개를 통해 간접적으로 통지하는 이유는 **라우터가 TCP 프로토콜을 지원하지 않기 때문**이다.           


----

## 캡슐화
아래 그림은 TCP 세그먼트가 상하 계층의 데이터 단위와 어떤 관계에 있는지 설명한다.     
**1)** 상위 계층에서 내려온 전송 데이터는 TCP 헤더 뒤에 추가되어 TCP 세그먼트를 구성한다.     
**2)** TCP 세그먼트는 다시 IP 프로토콜로 보내지고,      
**3)** IP 헤더에 캡슐화되어 데이터 링크 계층으로 보내진다.    


![image](https://user-images.githubusercontent.com/76824611/165293108-7da1634c-8545-4101-bf58-82ba82033aef.png)


---
----


# **포트 번호**
포트 Port 번호는 TCP와 UDP가 상위 계층에 제공하는 주소 표현 방식이다.  
유닉스 환경에서는 소켓으로 포트를 구현하므로, TCP/UDP 프로토콜을 사용하려면 소켓 시스템 콜의 인터페이스를 알아야 한다.     
소켓 Socket 시스템 콜을 이용해 TCP 연결 설정이 되면 통신 양단의 프로세스가 사용하는 고유 주소는 **해당 호스트의 IP 주소**와 **호스트 내부의 포트 번호**가 **조합**된 형태이다.    



**[클라이언트-서버의 연동]**    
**1)** 서버가 먼저 실행되고,       
**2)** 클라이언트가 서버와 연결을 시도하는 방식으로 이루어진다.      
이때 연결을 원하는 서버와 접속하려면 서버의 **IP 주소**와 **포트 번호**를 알아야 한다.            

**[Well-known 포트]**           
인터넷 환경에서 많이 사용하는 네트워크 응용 서비스의 서버 프로세스에 할당된 포트 번호          
➡ 전 세계 모든 컴퓨터가 동일한 포트 번호를 사용하도록 권고받고 있다.     
➡ 예를 들어, FTP, 전자 메일(SMTP), 웹 서비스(HTTP), DNS처럼 인터 넷에서 자주 사용하는 응용 서비스는 모두 고정된 포트 번호를 사용한다.        
![image](https://user-images.githubusercontent.com/76824611/165294505-44d71a51-5b81-4675-ae9c-b7b0943056d1.png)

네트워크 서비스를 제공하는 포트 번호는 컴퓨터의 파일 시스템에 보관되므로 일반 사용자가 포트 번호를 직접 지정하는 경우는 없다.    
**사용자**가 연결을 원하는 서버의 호스트 **IP 주소**만 클라이언트 프로그램에 알려주고,      
**포트 번호 선택은 프로그램에서 자동**으로 해준다.        
TCP와 UDP는 별도의 포트 주소 공간을 관리하므로 동일한 포트 번호를 사용할 수 있다.      
즉, 두 프로토콜에서 동일한 포트 번호를 할당해도 서로 다른 포트로 간주된다.        




