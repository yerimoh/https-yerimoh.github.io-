---
title: "[04] Deep learning 1: 신경망 학습"
date:   2020-03-10
excerpt: "데이터 주도 학습,손실 함수(loss function),오차 제곱 합(sum of squares for error, SSE),교차 엔트로피 오차(cross entropy error, CEE), 미니배치, 수치 미분, 학습 알고리즘 구현하기/ 경사하강법"
category: [Deep Learning]
layout: post
tag:
- Deep Learning
order: 0

comments: true
---

# 목차 
- [수치 미분](#수치-미분)
  * [미분](#미분)
  * [구현시 주의](#구현시-주의)
  * [중심 차분 or 중앙 차분](#중심-차분-or-중앙-차분)
  * [편미분](#편미분)
  * [경사법(경사 하강법)](#경사법(경사-하강법))
    + [수식](#수식)
  * [신경망에서의 기울기](#신경망에서의-기울기)


---

👀, 🤷‍♀️ , 📜    
이 아이콘들을 누르시면 코드, 개념 부가 설명을 보실 수 있습니다:)

------

# 수치 미분
아주 작은 차분으로 미분하는 것
Cf) 해석적으로 미분(analytic): 오차를 포함하지 않는 ‘진정한 미분’ 값    
수학시간에 배우건 해석적 미분 **이의 근사치**를 구하는건 수치미분    

----

## 미분
x의 ‘작은 변화’가 함수 f (x )를 얼마나 변화시키느냐     
![image](https://user-images.githubusercontent.com/76824611/117404683-534b9a80-af45-11eb-9d4d-b321a2f88305.png)
좌변: f (x)의 x에 대한 미분(x에 대한 f (x )의 변화량)을 나타내는 기호

-----

## 구현시 주의
* h를 너무 작은 값으로 설정하면 반올림 오차가 일어남(0이됨)  
  * **$$10^{-4}$$** 정도가 적당  

* 원래 미분    
  *  x 위치의 함수의 기울기(이를 접선이라 함)에 해당   
* 여기서: (x + h )와 x 사이의 기울기   
  * 구현값 엄밀히 일치하지 않음(h를 무한히 0으로 좁히지 못하므로)   

* 수치미분엔 오차가 포함됨  
  -> 이는 전방 차분   
![image](https://user-images.githubusercontent.com/76824611/117405154-1a5ff580-af46-11eb-8ee6-ba8011681824.png)





## 중심 차분 or 중앙 차분
위의 오차를 줄이기 위해 (x + h )와 (x -h )일 때의 함수 f의 차분을 계산하는 방법사용    
x를 중심으로 그 전후의 차분을 계산한다는 의미   

[구현]
```python
def numerical_diff(f, x): 
h = 1e-4 # 0.0001
return (f(x+h) - f(x-h)) / (2*h)
```

[계산]
```python
# 아무 함수나 정의
def function_1(x):
      return 0.01*x**2 + 0.1*x

  # 이 함수 시각화
  import numpy as np 
  import matplotlib.pylab as plt

  x = np.arange(0.0, 20.0, 0.1)
  y = function_1(x) 

  plt.xlabel("x") 
  plt.ylabel("f(x)") 
  plt.plot(x, y) 
  plt.show()
 
  # 이 함수 미분값 확인
  numerical_diff(function_1, 5)
```

## 편미분
![image](https://user-images.githubusercontent.com/76824611/117405587-d4eff800-af46-11eb-8f0e-2216352a1cd9.png)
변수가 2개인 함수 미분    
변수가 2개인 함수 식 구현   

[구현]
```python
#미분이 아닌 변수 2개인 함수 단순 식 구현
def function _2(x): 
  return x[0]**2 + x[1]**2
  # 또는 return np.sum(x**2)
```
x는 넘파이 배열이라고 가정하여 시각화
![image](https://user-images.githubusercontent.com/76824611/117405756-15e80c80-af47-11eb-8396-960c2fe66ed3.png)

    
**[미분법]**
* 따로 함수를 정의하고 각각 미분해서 더하기    
* 한번에 $$x_0=3, x_1=4$$일 때 $$(x_0, x_1)$$ 양쪽 편미분을 묶어 계산
   * 기울기: 모든 변수의 편미분을 벡터로 정리한 것   
      ![image](https://user-images.githubusercontent.com/76824611/117406144-a0307080-af47-11eb-8a75-ae770a2e28e4.png)
 
[기울기 구현]
```python         
def numerical_gradient(f, x):
  h = 1e-4 # 0.0001
  grad = np.zeros_like(x) 
  # x 와 형상이 같고 그 원소가 모두 0인 배열

  for idx in range(x.size):
    tmp_val = x[idx] 

    # f(x+h) 계산
    x[idx] = tmp_val + h 
    fxh1 = f(x)


    # f(x-h) 계산
    x[idx] = tmp _val - h 
    fxh2 = f(x)

    grad[idx] = (fxh1 - fxh2) / (2*h) 
    x[idx] = tmp_val # 값 복원

    return grad

#미분값 넣어서 프린트 해보기
numerical _gradient(function _2, np.array([3.0, 4.0])) 

>>>array([ 6., 8.])
```
![image](https://user-images.githubusercontent.com/76824611/117406474-11702380-af48-11eb-9322-09ca4af00ba7.png)

* 위의 결과값은 방향을 가진 벡터(화살표)로 그려짐   
* 그림을 보면 기울기는 함수의 ‘가장 **낮은** 장소(최솟값)’를 가리키는 것 같음     
* 화살표가 한점을 향함        
 * ‘가장 낮은 곳’에서 멀어질수록 화살표의 크기가 커짐        

그런데 꼭 ‘가장 낮은 곳’만 찾는 것도 아님 = 기울기는 **각 지점 에서 낮아지는 방향**을 가리킴    
* 기울기가 가리키는 쪽은 각 장소에서 함수의 **출력 값을 가장 크게 줄이는 방향** (출력 값을 줄이면 정확도가 올라가죠?)    

## 경사법(경사 하강법)
**[INTRO]**    
일반적인 문제에서 손실함수를 찾을 때 매개변수 공간이 광대하여 **어디가 최솟값이 되는 곳인지를 짐작할 수 없음**       
이런 상황에서 기울기를 잘 이용해 **함수의 최솟값(또는 가능한 한 작은 값)**을 찾으려는 것이 경사법입니다.    
 
**[PROBLEM]**
함수가 극솟값, 최솟값, 또 안장점 **saddle point** 이 되는 장소에서는 기울기가 0-> 반드시 최솟값아님      
**plateau, 플래토**: 복잡하고 찌그러진 모양의 함수라면 (대부분) 평평한 곳으로 파고들면서 학습이 진행되지 않는 정체기에 빠질 수 있음    
**안장점**: 안장점은 어느 방향에서 보면 극댓값이고 다른 방향에서 보면 극솟값이 되는 점
![image](https://user-images.githubusercontent.com/76824611/117407045-f05c0280-af48-11eb-84b2-7f8eb9891613.png)


**[경사법 (gradient method)]**       
1) 현 위치에서 기울어진 방향으로 일정 거리만큼 이동.   
2) 이동한 곳에서도 마찬가지로 기울기를 구하고,    
3) 또 그 기울어진 방향으로 나아가기를 반복   
-> 이렇게 해서 함수의 값을 점차 줄이는 것이 경사법      

```경사 하강법 gradient descent method```: 최솟값을 찾을 때 [more learn](https://yerimoh.github.io/DL7/)    
```경사 상승법 gradient ascent method```: 최댓값을 찾을 때     

### 수식
![image](https://user-images.githubusercontent.com/76824611/117407330-5ba5d480-af49-11eb-8726-2251a807f246.png)
* **$$η$$**(= eta, 에타): 갱신하는 양을 나타냄. 학습률 **learning rate**이라고도 함   

* 1회갱신( 이를 반복해야하여 서서히 함숫값down)   
* 변수의 수가 늘어도 같은 식(각 변수의 편미분 값)으로 갱신   

[학습률]    
한 번의 학습으로 얼마만큼 **학습**해야 할지,      
매개변수 값을 얼마나 **갱신**하느냐를 정하는 것     
* 0.01이나 0.001 등 미리 특정 값으로 정해둬야 함      
* (너무 크거나 작으면 좋은장소 찾지 못함)         
이와 같은 매개변수를 하이퍼파라미터 **hyper parameter**, 초매개변수라고 함      
* < 자동으로 설정되는 가중치와 편향 같은 신경망 매개변수와 달리 **사람이 직접 설정**해야 하는 매개변수> 

[구현]
```python   
# 인수 f: 최적화하려는 함수
# init_x: 초깃값
# lr: learning rate를 의미하는 학습률
# step_ num은 경사법에 따른 반복 횟수
def gradient_descent(f, init_x, lr = 0.01, step _num = 100):
  x = init _x

  #미분값 조작
  for i in range(step _num):
    grad = numerical_gradient(f, x) 
    x - = lr * grad return x

#그림을 그려주는 소스코드 ch04/gradient_ method.py
```

## 신경망에서의 기울기
**기울기**   
가중치 매개변수(W)에 대한 손실 함수의 기울기(L)     
아래의 두 형상(행과 열의 크기)가 같아야 함    
![image](https://user-images.githubusercontent.com/76824611/117408092-64e37100-af4a-11eb-87e8-088bb80d4d5e.png)
* 경사는 2번째처럼 나타냄   
  * EX) 1행 1번째 원소: $$w_11$$을 조금 변경했을 때 손실 함수 L이 얼마나 변화하느냐를 나타냄


[구현(기울기 구하는 소스코드)]
```python 
import sys, os 
sys.path.append(os.pardir) 
import numpy as np
from common.functions import softmax, cross _entropy _error 
from common.gradient import numerical _gradient
  
#simpleNet 클래스는 형상이 2×3인 가중치 매개변수 하나를 인스턴스 변수로 갖음
# randn-> 가우시안 표준 정규분포에서 난수 매트릭스 어래이 생성
class simpleNet:
  def __init__(self):
    self.W = np.random.randn(2,3) # 정규분포로 초기화

  # 예측을 수행, 곱해!
  def predict(self, x):
    return np.dot(x, self.W)

  # 손실 함수의 값을 구함
  # x는 입력 데이터, t는 정답 레이블
  def loss(self, x, t):
    z = self.predict(x) 
    y = softmax(z) 
    loss = cross_entropy_error(y, t)

return loss
```
