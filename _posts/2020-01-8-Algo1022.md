---
title: "[1022] (파이썬)leet code_21. Merge Two Sorted Lists"
date:   2020-01-8
excerpt: "두 정렬 리스트의 병합"
category: [Coding test]
layout: post
tag:
- Coding test
comments: true
---

# 목차
- [가장 흔한 단어](#가장-흔한-단어)
  * [문제](#문제)
- [풀이](#풀이)
- [**풀이과정**](#--풀이과정--)
  * [1. 전처리](#1-전처리)
  * [2. 최빈값 뽑기](#2--최빈값-뽑기)
- [전체 코드](#전체-코드)



-----

👀, 🤷‍♀️ , 📜    
이 아이콘들을 누르시면 코드, 개념 부가 설명을 보실 수 있습니다:)

------





# 두 정렬 리스트의 병합
난이도| ★     
[리트코드 819. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)


## 문제

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.




**Example1:**  
![image](https://user-images.githubusercontent.com/76824611/150304294-830b98da-ad80-415a-87ad-c2cca557ef98.png)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```


**Example2:**  
```
Input: list1 = [], list2 = []
Output: []
```


**Example3:**  
```
Input: list1 = [], list2 = [0]
Output: [0]
```

**[제한]**    
* The number of nodes in both lists is in the range [0, 50]     
* -100 <= Node.val <= 100    
* Both list1 and list2 are sorted in non-decreasing order.    


**[전제]**    
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
```


---
----


# 풀이


들어가기 전 알아 둘 개념     
* [병합정렬]()          
             








-------





# **풀이과정** 
이 문제는 크게 두가지 과정을 거친다.        
1️⃣ 전처리(문자만 골라서 소문자로 바꾸로 공백으로 나누기/ banned 단어 빼기)해서 새로운 딕셔너리 만들기              
2️⃣ 전처리한 딕셔너리에서 최빈값 뽑기          
  


----

## 1. 전처리    
여기서는, **정렬된 리스트**라는 점이 중요하다.       
이 문제는 정렬된 두 리스트를 주는 것 이므로  [병합 정렬](https://yerimoh.github.io/Algo030/)의 마지막 부분을 이용하면 된다.              
죽 첫 번째 값부터 차례대로만 비교하면 한 번에 해결된다(첫 번째부터 비교하면서 리턴하면 쉽게 풀 수 있는 문제다)            


먼저 전체 코드부터 살펴보자.   
```python
def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
  if (not l1) or (l2 and l1.val > l2.val): 
    l1, l2 = l2, l1 
  if l1:
    l1.next = self.mergeTwoLists(l1.next, l2) 
  return l1
```

코드만 보면 이해가 되지 않으니 하나씩 뜯어보겠다.    

    
1) **스왑 Swap**: 먼저 l1 과 l2 의 값을 비교해 **작은 값**이 **왼쪽**에 오게 하고,   
2) ```l1.next```로 그다음 값이 엮이도록 재귀 호출한다     
이것이 이 전체 코드의 전부이다.    


----

## 스왑 Swap 
조금더 세부적인 설명을 위해   
여기서 첫 번째 if 문인 괄호로 엮인 부분과 변수를 스왑 Swap 하는 부분부터 살펴보자.    
```python
if (not l1) or (l2 and l1.val > l2.val): # 괄호 생략 가능 # (not l1) or (l2 and (l1.val > l2.val))
  l1, l2 = l2, l1 
```
➕ or 보다 **and** 가 **먼저 실행**된다는 점을 알아두자     
➕ 또한 l1.val은 l1의 value 즉 l1의 값인 1,2,4를 지칭하는 것이다.       

l1 과 l2 의 값을 비교해 **작은 값**이 **왼쪽**에 오게 하고,    
이제 다음과 같이 변수를 스왑한다.    
l1, l2 = l2, l1    

또한 조건에 not l1있는 이유는   

**Example3:**  
```
Input: list1 = [], list2 = [0]
Output: [0]
```
를 처리하기 위해서 이다.



-----

## 재귀 호출
```python
if l1:
  l1.next = self.mergeTwoLists(l1.next, l2) 
```
이후에는 l1 의 next 를 재귀호출하면서 다음번 연결 리스트가 계속 스왑될 수 있게 한다.     



-----

## 시각화
이제 전체를 실행하면 연결 리스트가 어떻게 변경되는지, 다음 그림에서 살펴보자.     
먼저, 이 그림에서 L1 과 L2 는 두 연결 리스트의 첫 번째 값을 각각 가리킨다.      
* 참고로 그림 에서는 구분을 쉽게 하기 위해 대문자 L 을 사용했지만, 코드에서는 소문자 l 을 사용한다.    
* 즉 그림에서 L1 과 L2 는 코드에서는 변수 l1 과 l2 가 된다.      
* 그런데 아래 그림은 ```l1.val > l2.val```를 만족시키지 못하므로 swap하지 않고 첫번쨰 if 문을 실행시키지 않는다.             
![image](https://user-images.githubusercontent.com/76824611/150321676-52709698-dadc-4b93-962f-8dc976866073.png)

그럼 아직 l1이 끝나지 않았으므로 두번째 if문이 실행된다.      
두번째 if문은 l1의 next로 가게 하여 다음 수와 l2를 비교하게 해준다.       
*  ```l1.val > l2.val```이므로 두 값을 swap하는 첫번쨰 if문을 실행시킨다.     
*  노드 자체를 swap하는 것이기 떄문에 그 노드가 갖고있는 링크까지 같이 옯겨진다는것에 유의하자  
![프레젠테이션2](https://user-images.githubusercontent.com/76824611/150327835-7903a186-321b-42ca-ac8e-ea16d50baa33.gif)
<details>
<summary>📜 과정 자세히 보기</summary>
<div markdown="1">
  
![image](https://user-images.githubusercontent.com/76824611/150328285-ed2297a6-035c-48ef-8ed4-3909362e0874.png)
![image](https://user-images.githubusercontent.com/76824611/150328333-e78e18cc-87ad-4a64-bd79-6ea29b279549.png)

  
</div>
</details>  

위의 과정을  L1이 마지막으로 갈 때 까지 반복하는 것이다

그럼 계속 반복해서 내려가보자    
이제 두번 째 if문을 실행한다.  
* 즉 L1이 이어진 다음 노드에 위치한다.     
![image](https://user-images.githubusercontent.com/76824611/150329238-17fdfcd4-af8e-498a-a560-8f2ceb0fe508.png)



이제 다시 처음 if문으로 돌아가자.    
* ```l1.val > l2.val```이므로 두 값을 swap하는 첫번쨰 if문을 실행시킨다.    


   
-

<details>
<summary>📜 re.sub 간단하게 보기 </summary>
<div markdown="1">
	
> ```re.sub(뭘바꿔, 뭘로 바꿔, 바꿀 문자열)```   

'apple' 또는 'orange'를 찾아서 'fruit'로 바꿈    

```python
re.sub('apple|orange', 'fruit', 'apple box orange tree')    # apple 또는 orange를 fruit로 바꿈
'fruit box fruit tree'
```     	
  
</div>
</details>  


골라낸것을 ```lower()```를 통해 소문자로 바꾸고 ```split()```를 기준으로 나눈다.            
```re.sub(r'[^\w]', ' ', paragraph).lower().split()```.     


그리고 banned 단어를 포함하지 않기 위해 간단한 조건도 섞어보자     
```if word not in banned```.     

그럼 [리스트 컴프리헨션](https://yerimoh.github.io//Algo2/#mypy-%EC%84%A4%EC%B9%98)으로 모든 위의 조건들을 반영한 새로운 딕셔너리를 만들어보겠다.      
```words = [word for word in re.sub(r'[^\w]', ' ', paragraph).lower().split() if word not in banned]```.     


-----

## 2. 최빈값 뽑기   


다음과 같이 각 단어의 개수를 헤아려 보자.     

차이썬의 기본 타입에서 _argmax_ 를 지원하고 있지 않기 때문에(코딩테스트는 외부 라이브러리를 지원하지 않는다) 딕셔너리 항목의 각 개수를 세는 ```collections.Counter```를 사용한다.  
즉, 개수를 처리하는 부분은 Counter 모듈을 사용하면 좀 더 깔끔하게 처리할 수 있다.   

여기서 개수를 담아두는 변수는 딕셔너리를 사용하며 ```defaultdict()``` 를 사용해 int 기본 값이 자동으로 부여되게 했다.     
즉 이 코드를 사용하면 ```counts = collections.Counter(words)``` 이렇게 나온다.          
```python
# input 
words =['bob', 'a', 'ball', 'the', 'ball', 'flew', 'far', 'after', 'it', 'was']

count = collections.Counter(words)
print(count.most_common)
#<bound method Counter.most_common of Counter({'ball': 2, 'bob': 1, 'a': 1, 'the': 1, 'flew': 1, 'far': 1, 'after': 1, 'it': 1, 'was': 1})>
```

        
다음 코드는 words 에서 가장 흔하게 등장하는 단어의 첫 번째 값을 most_common(1) 으로 추출한다.      
문제의 입력값에서는 [('ball', 2)] 가 되며,     
이 값의 [0][0] 을 추출해서 최종 적으로 첫 번째 인덱스의 키를 추출하게 된다.      
이렇게 추출한 키인 ball 은 가장 흔한 단어가 되므로, 이제 이 값을 리턴한다.        

	
	
-----


------
----


# 전체 코드

위를 구현한 전체 코드는 다음과 같다


```python
class Solution:
    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:
        words = [word for word in re.sub(r'[^\w]',' ',paragraph).lower().split() if word not in banned]
        print(words)
        count = collections.Counter(words)
        return count.most_common(1)[0][0]

```

