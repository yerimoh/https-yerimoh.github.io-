---
title: "[1017] (파이썬)leet code_79. Queue Reconstruction by Height "
date:   2020-01-13
excerpt: ""
category: [Coding test]
layout: post
tag:
- Coding test
comments: true
---



# 목차






----






# 이진 트리의 최대 깊이
난이도 | ★        
[리트코드 104.](https://leetcode.com/problems/maximum-depth-of-binary-tree/)   

## 문제
[eng]   
You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.

Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).

[kor]   

여러 명의 사람들이 줄을 서 있다. 각각의 사람은 (h, k) 의 두 정수 쌍을 갖는데, h 는그 사람의 키, k 는 앞에 줄 서 있는 사람들 중 자신의 키 이상인 사람들의 수를 뜻한다.   
이 값이 올바르도록 줄을 재정렬하는 알고리즘을 작성하라.   


```
Example 1:
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
``` 

• 설명    
키가 5 인 사람이 가장 먼저 섰고, 앞에는 아무도 없다. 7 인 사람이 뒤따르고, 그보다 키가 더 큰 사람은 아무도 없다. 5 인 사람이 섰으며, 앞에 5, 7 두 명이 자신보다 크거나 같다. 6 인 사람의 앞에는 자신보다 큰 키 7 인 사람 한 명이 있다. 4 인 사람 앞에는 5, 7, 5, 6 네 명이 있다. 마지막으로 7 인 사람 앞에 자신보다 크거나 같은 이는 키가 7 인 사람 한 명이다

```
Constraints:

1 <= people.length <= 2000
0 <= hi <= 106
0 <= ki < people.length
It is guaranteed that the queue can be reconstructed.
```

**[전제]**   
```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        
```

----



## 문제 풀기 전 알고 갈 개념
* [큐]()       
* [greedy algo](https://yerimoh.github.io/Algo9/)           




----


## 풀이과정

### 1) 예외처리  
먼저, 트리에 아무것도 없을 때 0을 반환하는 예외처리부터 해주겠다   
제일 쉬우니까 후딱 끝내버리자   
```
Example 4:
Input: root = [0]
Output: 1
```

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
```


### 2) 본 문제 풀이
BFS(너비 우선 탐색)로 풀이해보겠다     
* 큐로 구현    
* 재귀사용 불가      

![image](https://user-images.githubusercontent.com/76824611/122947234-f735bc00-d3b4-11eb-9278-556bec9d949f.png)




**[2.1 풀이 준비]**    
* 큐 선언     
* 깊이를 기록할 변수 준비    

```python
def maxDepth(self, root: TreeNode) -> int:
    ...
    q = collections.deque([root]) depth = 0
    depth = 0
```    
![image](https://user-images.githubusercontent.com/76824611/122945819-ce60f700-d3b3-11eb-8c17-abac29d34bce.png)




**[2.2 풀이 ①]**    
depth=1 검출   
* for문 첫번째로 돌림      
![image](https://user-images.githubusercontent.com/76824611/122944746-09165f80-d3b3-11eb-8ed7-ae85b4d93a17.png)
![image](https://user-images.githubusercontent.com/76824611/122944766-0c115000-d3b3-11eb-8b75-65c06bcbc0cc.png)
![image](https://user-images.githubusercontent.com/76824611/122947387-10d70380-d3b5-11eb-8c1b-9f595606b3b4.png)




**[2.3 풀이 ②]**    
depth=2 검출   
* for문 두번째로 돌림      
![image](https://user-images.githubusercontent.com/76824611/122955600-3404b180-d3bb-11eb-9856-396f82260b59.png)
![image](https://user-images.githubusercontent.com/76824611/122947461-23513d00-d3b5-11eb-9774-382de747fca6.png)



**[2.4 풀이 ②]**    
depth=3 검출   
* for문 세번째로 돌림  
![image](https://user-images.githubusercontent.com/76824611/122955712-4b439f00-d3bb-11eb-8763-6c8e33e75f87.png)
![image](https://user-images.githubusercontent.com/76824611/122955764-58f92480-d3bb-11eb-8b05-2796910427dd.png)


## 전체 코드
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if root is None:
            return 0
        q = collection.deque([root])
        depth = 0

        while q:
            depth+=1
            for _ in range(len(queue)):
                cheak = q.popleft()
                if cheak.left:
                    q.append(cheak.left)
                if cheak.right:
                    q.append(cheak.right)
        
        return depth
```
