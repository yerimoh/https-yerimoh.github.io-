---
title: "[011] [INDEX] Computer Network: IP 포로토콜(IPv4)"
date:   2021-02-25
excerpt: "네트워크 계층의 기능, IP 프로토콜, IP 헤더 구조, DS/ECN, 패킷 분할, 주소 관련 필드, 기타 필드, 체크썸 계산하는 법"
category: [CS basic]
layout: post
tag:
- CS basic
order: 0

comments: true
---


# 목차 
- [**네트워크 계층의 기능**](#--네트워크-계층의-기능--)
- [**IP 프로토콜**](#--ip-프로토콜--)
- [**IP 헤더 구조**](#--ip-헤더-구조--)
  * [DS/ECN](#ds-ecn)
  * [패킷 분할](#패킷-분할)
  * [주소 관련 필드](#주소-관련-필드)
  * [기타 필드](#기타-필드)


---
----


# **네트워크 계층의 기능**
네트워크 계층 Network Layer의 기본 기능은 송수신 호스트 사이의 패킷 전달 경로를 선택하는 라우팅이다.       
라우팅 과정에서 일어나는 문제도 네트워크 계층에서 처리한다.      
이와 관련된 대표적인 기능이 네트워크의 특정 지역에 트래픽이 몰리는 현상을 다루는 혼잡 제어와 라우터 사이의 패킷 중개 과정에서 다루는 패킷의 분할과 병합이다.    
네트워크 계층에서 제공하는 주요 기능을 정리하면 다음과 같다.   


**[라우팅]**     
* 네트워크의 구성 형태에 대한 정보는 라우팅 테이블 Routing Table 이라는 기억 장소에 보관된다.     
* 그리고 이 정보를 이용해 패킷이 목적지까지 도달하기 위한 경로를 선택한다.    
* 송수신 호스트 사이의 패킷 전달 경로를 선택하는 과정을 라우팅 Routing 이라고 한다.    
* 라우팅 테이블 정보는 네트워크 관리자나 네트워크 자신의 판단에 의해 계속 변경될 수 있다.       


**[혼잡 제어]**      
* 네트워크에 패킷 수가 과도하게 증가하는 현상을 혼잡 Congestion 이라 하고, 혼잡 현상을 예방하거나 제거하는 기능을 혼잡 제어 Congestion Control 라 한다.      
* 혼잡이 발생하면 네트워크 전체의 전송 속도가 급격히 떨어지므로 혼잡이 발생하지 않도록 관리해야 한다.     
* 특히 네트워 크의 특정 지역에서 혼잡이 발생하면, 혼잡의 특성상 주위로 빠르게 확산될 가능성이 높다.   


**[패킷의 분할과 병합]**     
* 상위 전송 계층에서 송신을 요구한 데이터는 최종적으로 MAC 계층의 프레임 구조에 정의된 형식으로 캡슐화되어 물리적으로 전송된다.     
* 따라서 전송 계층에서 보낸 데이터가 너무 크면 여러 개의 패킷으로 작게 쪼개 전송해야 한다. 이와 같이 큰 데이터를 여러 패킷으로 나누는 과정을 패킷 분할 Segmentation 이라 하고, 반대로 목적지에서 분할된 패킷을 다시 모으는 과정을 병합 Reassembly 이라 한다.      
* 패킷의 분할과 병합 과정이 양 끝단 시스템 사이에서 이루어지는 경우라면 전송 계층이 동작하는 종단 수신 시스템에 분할된 패킷을 보내고, 네트워크 계층에서 이루어지는 경우라면 중간의 각 라우터에서 분할과 병합을 반복한다.    



---
----


# **IP 프로토콜**    
인터넷 환경에서 네트워크 계층의 데이터 전송 프로토콜로 이용됨      
* 지원 되는것: 호스트 주소 표기, 패킷 분할에 관한 기능        
* 지원되지 않는 것: 단대단 End-to-End 형식의 오류 제어나 흐름 제어 기능            


IP 프로토콜에서 **라우터 간의 패킷을 중개**할 때는 **Best Effort**라는 원칙에 따라 전송하는데, 이 방식은 전송 패킷이 수신 호스트에 100% 도착하는 것을 보장하지 않는다.       
➡ 따라서 IP 프로 토콜에서 제공하지 않는 **전송 오류 문제를 상위 계층에서 고려**해야 한다.    

**[IP 프로토콜의 주요 특징]**      
* 비연결형 서비스를 제공한다.     
* 패킷을 분할/병합하는 기능을 수행하기도 한다.    
* 데이터 체크섬은 제공하지 않고, 헤더 체크섬만 제공한다.    
* Best Effort 원칙에 따른 전송 기능을 제공한다.     


---
---


# **IP 헤더 구조**    
IP 프로토콜에서 정의된 패킷의 IP 헤더 IP Header 구조이다.     
상단의 숫자는 비트 수이다.    

![image](https://user-images.githubusercontent.com/76824611/165087535-0310c54f-d7b8-4ee2-8840-8e3fa27a9c63.png)


여기서는 헤더 필드를 연관된 종류별로 묶어 설명한다.    


---

## DS/ECN
DS(Differentiated Services) 와 ECN(Explicit Congestion Notification) 필드가 도입되기 전에는 8비트의 Service Type(DS+ECN) 필드로 정의되어 우선순위, 지연, 전송률, 신뢰성 등의 값을 지정할 수 있었다.     
**[Service Type 필드]**     
* IP 프로토콜이 사용자에게 제공하는 서비스의 품질에 관련된 내용을 표현하는데, 각 비트 값의 의미는 아래의 표와 같다.     
![image](https://user-images.githubusercontent.com/76824611/165093530-549818fd-ce24-46bc-af8f-6f9c90ea39fc.png)


**[ECN 필드]**       
* 차등 서비스 개념이 도입되면서 Service Type 필드는 6비트의 DS 필드와 2비트의 ECN 필드로 새로 정의되었다.   
* 이는 인터넷에서 다양한 트래픽 요구 조건을 필요로 하는 서비스들에 대하여 **서로 다른 수준의 QoS Quality of Service 를 지원**하기 위함이다.      
* DS를 사용하기 위해 사전에 서비스 제공자와 서비스 이용자 사이에 서비스 등급에 대한 합의가 이루어지며, 동일한 DS 값을 갖는 트래픽들은 동일한 서비스 등급으로 처리된다.    
➡ 이러한 처리 과정은 라우터에 의하여 이루어지므로 기존 응용 프로그램들을 변경할 필요가 없다.     
* ECN 필드 값의 의미는 아래의 표와 같다.     
여기서 ECT 0과 ECT 1은 동일한 의미이며, 어느 것을 사용해도 무방하다. 송신 호스트가 라우터에게 IP 패킷에 캡슐화된 TCP 프로토콜이 ECN 기능을 지원한다고 알려주기 위하여 사용된다. ECN 기능을 위하여 TCP 프로토콜의 헤더에 ECE 필드와 CWR 필드가 추가되었다
![image](https://user-images.githubusercontent.com/76824611/165102784-de600447-d59f-4173-b483-1ccf9e2f4e97.png)


**[DS 필드 값]**     
* 차등 서비스 개념이 도입되면서 Service Type 필드는 6비트의 DS 필드와 2비트의 ECN 필드로 새로 정의되었다.     
* DS 코드포인트 CodePoint 라고도 하는 DS 필드 값은 **차등 서비스의 기준**이 되는 레이블 값으로 64개의 트래픽 클래스를 정의할 수 있다.       
* DS 서비스는 비교적 단순한 원리에 의하여 차등화된 서비스를 제공하지만 내부적인 처리 과정은 복잡한 구조에 의하여 이루어진다.     


----

## 패킷 분할
IP 프로토콜은 상위 계층에서 내려온 전송 데이터가 패킷 하나로 전송하기에 너무 크면 분할 Fragmentation 해 전송하는 기능을 제공한다. 다음은 **패킷 분할**과 관련된 필드이다.    


**[Identification(식별자 혹은 구분자)]**      
* IP 헤더의 두 번째 워드에는 패킷 분할과 관련된 정보가 포함된다.     
* 이 중 Identification 필드는 송신 호스트가 지정하는 **패킷 구분자 기능**을 수행한다.      
* IP 프로토콜이 **분할한 패킷들에 동일한 고유 번호를 부여**함으로써, 수신 호스트가 Identification 번호가 같은 패킷을 **다시 병합 Reassembly** 할 수 있도록 해준다.      
* 패킷을 분할하지 않으면 패킷을 전송할 때마다 이 필드의 값을 하나씩 증가시킨다.      

**[DF (Don’t Fragment)]**          
* 패킷이 분할되지 않도록 한다.     
* 즉 값을 1로 지정하면 패킷 분할을 막을 수 있다.       
* 수신 호스트가 분할되어 입력된 패킷들을 병합하는 기능이 없을 때 사용한다.     
* 따라서 중간 경유 네트워크에서는 자신이 처리 가능한 패킷의 크기보다 큰 IP 패킷에 DF 필드가 설정되어 있으면 분할 기능을 수행하지 않고 패킷을 버린다.    


**[MF(More Fragment)]**     
* 분할된 패킷을 전송할 때는 여러 개의 분할 패킷이 연속해서 전송되므로 **MF 필드 값을 1**로 지정하여,** 분할 패킷이** **뒤에 계속됨**을 표시해주어야 한다.      
* 분할 패킷 중 **마지막 패킷은 MF 비트를 0으로 지정**하여 분할 패킷이 더 없음을 표시한다.         


**[Fragment Offset(분할 옵셋)]**      
* 패킷 분할이 이루어지면 12비트의 Fragment Offset 필드를 사용한다.      
* 저장되는 값은 분할된 패킷의 내용이 **원래의 분할 전 데이터에서 위치하는 상대 주소 값**이다.      
* 값은 8바이트의 배수이므로, Fragment Offset 값이 64라면 원래 데이터에서 64×8 = 512번째에 위치한다.      

-----

## 주소 관련 필드
* **Source Address**: 송신 호스트의 IP 주소     
* **Destination Address**: 수신 호스트의 IP주소      

**[IP 주소 체계]**     
* 주소 체계는 크게 다섯 종류이다.   
* **클래스 A, B, C**: 유니 캐스팅에서 이용     
* **클래스 D**: 멀티캐스팅에서 이용     
* **클래스 E**: 향후의 새로운 응용 환경을 위하여 잠정적으로 예약된 클래스     
![image](https://user-images.githubusercontent.com/76824611/165114860-8dacda75-3b2f-4eda-acbd-3d4c079559bc.png)

➕ **클래스 A, B, C**    
주소를 **network와 host 필드로 구분해 관리함**으로써, 클래스별로 **네트워크 크기**에 따라 **주소 관리를 다르게** 한다.     
* **network(네트워크)**: 네트워크 주소이다. 전 세계적으로 유일한 번호가 모든 컴퓨터 네트워크에 할당된다. 현재 이 주소의 할당은 NIC Network Information Center 에서 담당한다.        
* **host(호스트)** : 네트워크 주소가 결정되면 하위의 호스트 주소를 의미하는 host 비트 값을 개별 네트워크의 관리자가 할당한다. 
     * **클래스 A**: host 비트의 크기가 크기 때문에 규모가 큰 네트워크에서 사용   
     * **클래스 C**: 규모가 작은 네트워크에서 사용            


**[IP 주소 값에 따른 주소 체계]**     
* IP 주소 값을 통해 이 주소가 속한 클래스를 알 수 있다.     
* 이진수로 표현되면 그림에서 맨 왼쪽 비트와 비교해 바로 알 수 있다.     
* 십진수로 표현되면 A1.A2.A3.A4의 표현 방식에서 맨 왼쪽의 A1 값이 주소 대역중 어디에 속하는지에 따라 결정된다. ➡ 예를 들어, 211.223.201.30은 클래스 C의 주소이다.   
![image](https://user-images.githubusercontent.com/76824611/165116374-c651efc3-9584-4e30-ac02-c8d45784e506.png)
  

----


## 기타 필드
앞서 설명한 필드 외에도 IP 프로토콜에서는 다음과 같은 다양한 필드를 정의한다.            
**[Version Number(버전 번호)]**       
* IP 프로토콜의 버전 번호이다.     
* 현재 인터넷 환경에서 사용하는 IP 프로토콜은 버전 4이다.    
* IP 프로토콜의 새로운 버전인 IPv6과 구분하기 위해 기존 IP 프로토콜을 IPv4로 표현하기도 한다.    



**[Header Length(헤더 길이)]**      
* IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다.     
* 일반 패킷을 전송하는 경우에 헤더의 Options, Padding 필드가 빠지므로 IP 헤더의 최소 크기는 5이다.         


**[Packet Length(패킷 길이)]**     
* IP 헤더를 포함하여 패킷의 전체 길이를 나타낸다.       
* 필드의 크기가 16비트이므로 IP 프로토콜에서 지원하는 패킷의 최대 크기는 $$2^{16}-1$$바이트이다.         
* 그러나 이는 이상적인 최댓값으로, IP 프로토콜에서 65,535바이트의 IP 패킷을 전송해도 대부분 데이터 링크 계층에서 분할해 전송한다.       
* 따라서 실제 환경에서 IP 프로토콜은 IP 패킷을 더 작은 단위로 만든다. IP 패킷의 크기는 일반적으로 8,192바이트를 넘지 않는다.  

**[Time To Live(생존 시간)]**    
* 패킷 전송 과정에서 패킷이 **올바른 목적지를 찾지 못하면** 수신 호스트에 제대로 도착하지 않고, 네트워크 내부에서 떠돈다. 이런 현상을 방지하려고 Time To Live 필드를 사용한다.       
* 송신 호스트가 패킷을 전송하기 전에 네트워크에서 생존할 수있는 시간을 지정하고, 각 라우터에서는 패킷이 지나갈 때마다 필드 값을 감소시키면서 패킷을 중개한다. 임의의 라우터에서 Time To Live 값이 0으로 감소하면 패킷은 자동으로 버려지고, 패킷 송신 호스트에 ICMP 오류 메시지가 전달된다.       



**[Transport(전송 프로토콜)]**    
* IP 프로토콜에 데이터 전송을 요구한 전송 계층의 프로토콜을 가리킨다.     
* 전송 계층의 TCP 세그먼트와 UDP 데이터그램, 네트워크 계층의 ICMP 패킷은 모두 IP 패킷의 데이터를 의미하는 페이로드 Payload 부분에 캡슐화되어 전송된다.     
* 왼쪽의 숫자는 Transport 필드 값을 의미하며, TCP는 6, UDP는 17, ICMP는 1의 값이 저장된다.     
* 따라서 패킷 수신자는 페이로드 내부에 어느 프로토콜 정보가 있는지 판단할 수 있다.   
![image](https://user-images.githubusercontent.com/76824611/165145099-b0867f36-e215-4ed4-9f6d-23600510aa68.png)


**[Header Checksum(헤더 체크섬)]**     
* 전송 과정에서 발생할 수 있는 헤더 오류를 검출하는 기능으로, 데이터의 오류는 검출하지 않는다.      
* 이와 달리 계층 4 프로토콜인 TCP, UDP 헤더는 데이터와 헤더 오류를 모두 검출한다. 체크섬 계산 과정은 다음과 같다.      
* **체크썸 계산 과정**    
    * **1)** 먼저 Header Checksum 필드의 비트 값을 모두 0으로 설정     
    * **2)** 전체 헤더가 16비트 워드의 연속이라 가정하고 1의 보수 합을 수행한다.      
    * **3)** 이 값을 체크섬으로 하여 패킷을 전송함    
    * **4)** 수신 호스트는 1의 보수 합을 계산하여 계산 결과가 모두 1이면 전송 과정에 오류가 없다고 판단한다.   
    * **5)** 전송 과정에 오류가 발생하면 해당 패킷을 버리고, 이를 복원하는 일은 상위 계층에서 담당한다.    
    * **6)** IP 헤더 값은 라우터의 중개 과정을 거치는 동안에 계속 변경되므로 라우터를 거치는 과정에서 체크섬을 검증하고 재계산하는 과정이 반복적으로 이루어진다.    
* Options(옵션) : 네트워크 관리나 보안처럼 특수 용도로 이용할 수 있다.     
* Padding(패딩) : IP 헤더의 크기는 32비트 워드의 크기가 배수가 되도록 설계되어 있다. 앞서 설명한 필드의 전체 크기가 이 조건에 맞지 않으면 이 필드를 사용해 조정할 수 있다.    


<details>
<summary>📜 Header Checksum(헤더 체크섬) 구하는 예제 </summary>
<div markdown="1">
  
**0)** 비트의 의미를 파악하여 cheaksum 위치를 파악한다.     
* ```4500 003c 1c46 4000 4006 b1e6 ac10 0a63 ac10 0a0c```이라면,    
![image](https://user-images.githubusercontent.com/76824611/165150792-4e39f317-326a-4117-ae49-0d0931a765ef.png)
  
**1)** Header Checksum 필드의 비트 값을 모두 0으로 설정한다       
* 나머지도 16진수에서 2진수로 바꿔준다       
4500 -> 0100010100000000   
003c -> 0000000000111100   
1c46 -> 0001110001000110   
4000 -> 0100000000000000  
4006 -> 0100000000000110   
0000 -> 0000000000000000 // 체크섬이 0으로 설정됩니다.   
ac10 -> 1010110000010000   
0a63 -> 0000101001100011     
ac10 -> 1010110000010000   
0a0c -> 0000101000001100   
변환은 window 계산기 -> 프로그래머로 한다    
  
**2)**  더한 결과를 1의 보수로 만든다.     
- 더한결과: **2** 4e17 -> -> carry 발생시 더한다.   
![image](https://user-images.githubusercontent.com/76824611/165158548-7ccb4f6f-00ba-4bb6-a95b-d3930aa93eed.png)
  
- 1의 보수    
  : 그냥 1은 0으로 0은 1로
  ![image](https://user-images.githubusercontent.com/76824611/165158673-fb4268e2-95dc-4617-86eb-a15fae667025.png)

  
  
 
</div>
</details>  


