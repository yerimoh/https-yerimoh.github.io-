---
title: "[04] [INDEX] Computer Network: 계층 구조의 개념"
date:   2021-03-7
excerpt: "계층 구조의 개념, 계층적 모듈 구조, 프로토콜 설계 시 고려 사"
category: [CS basic]
layout: post
tag:
- CS basic
order: 0 

comments: true
---

# 목차  
- [**계층 구조의 개념**](#--계층-구조의-개념--)
- [**계층적 모듈 구조**](#-계층적-모듈-구조--)
  * [모듈화](#모듈화)
  * [계층 구조](#계층-구조)
- [**프로토콜 설계 시 고려 사항**](#--프로토콜-설계-시-고려-사항--)
  * [주소 표현](#주소-표현)
  * [오류 제어](#오류-제어)
  * [흐름 제어](#흐름-제어)
  * [데이터 전달 방식](#데이터-전달-방식)
- [**서비스 프리미티브**](#--서비스-프리미티브--)
  * [프리미티브가 처리되는 원리](#프리미티브가-처리되는-원리)
  * [프리미티브의 4단계](#프리미티브의-4단계)






---
---



# **계층 구조의 개념**
**[프로토콜 Protocol]**    
* [더 알아보기](https://yerimoh.github.io/CN02/#%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-protocol)       
* 네트워크에 연결된 시스템이 통신하려면 정해진 규칙에 따라 데이터를 주고받아야 하는데, 이러한 일련의 규칙을 뜻함.    
* 프로토콜의 동작 과정은 전송 오류율, 데이터 전달 경로, 전송 속도 등 **다양한 외부 요인**의 영향을 받음.         
➡ 적절한 대응 방안을 마련해 **효율적으로 관리**해야 하는데, 프로토콜의 설계 과정은 **모듈 Module화**를 통하여 이루어짐. 이렇게 함으로써 사용자에게 더 편리하고 간편한 통신 기능을 제공 가능.    


----
----


# **계층적 모듈 구조**
일반적으로 복잡하고 큰 시스템의 기능은 특정 단위의 모듈로 나누어 설계함.    
모듈은 **독립적**으로 동작하면서도 **상호 유기적**으로 통합될 수 있어야 함.    
그러므로 모듈 사이에는 적절한 인터페이스가 필요함.   


## 모듈화
* 복잡한 시스템을 기능별로 모듈화하면 시스템 구조가 단순해져서 전체 시스템을 이해하기 쉬움.    
* 또한 각 단위 모듈이 독립적인 기능을 수행하기 때문에 고장이나 업그레이드 등의 상황에 손쉽게 대처 가능.  

**[소프트웨어 측면의 모듈화]**    
* 일반 프로그래밍 언어에서는 함수 개념을 사용해 전체 프로그램을 모듈화 가능.     
* 함수별로 특정 기능을 독립적으로 수행하도록 함으로써, 각 함수가 개별적으로 설계되고 구현됨     
* 함수 사이의 **인터페이스는** 함수의 **매개변수에** 의해서만 이루어지므로 전체 시스템을 이해하기가 훨씬 쉬움     


---


## 계층 구조
분할된 모듈들은 협력 관계를 유지하면서 유기적으로 동작함.     
대부분의 모듈 구조에서는 **특정 모듈이 다른 모듈에 서비스를 제공하는 형식**의 계층 구조를 이룸.    


**[작동 방식]**
* 네트워크 에서도 독립적인 고유 기능을 수행하는 모듈들이 상하위의 계층 구조로 연결되어 동작함.         
* ❶ : 계층 구조에서는 상위 계층이 하위 계층에 특정 서비스를 요청하는 방식으로 동작    
* ❷ : 요청을 받은 하위 계층은 해당 서비스를 실행하여 그 결과를 상위 계층에 돌려줌     
* 하위 계층의 실행 결과는 상위 계층에 결과 값을 직접 전달하는 방식이 될 수도 있고, 주변 환경 값을 변경하는 부수 효과 Side Effect 방식일 수도 있음     
![image](https://user-images.githubusercontent.com/76824611/163329160-ab373398-b891-432e-9ddf-ae734fab9289.png)


**[예시로 이해]**   
자동차의 경우를 예로 들어보자.     
운전자가 자동차의 속도를 줄이려면 브레이크를 밟아야 하고, 브레이크를 누르는 정도에 따라 속도가 줄어든다.   
* **상위 계층**: 운전자     
* **하위 계층**: 자동차 내부에서 속도를 줄이는 기능        
* **인터페이스**: 운전자와 감속 모듈 사이에는 브레이크       

**[모듈화된 계층 구조 프로토콜의 장점]**     
* 복잡하고 큰 시스템을 기능별로 작게 분류해서 간단하고 작은 시스템으로 재구성 가능.    
➡ 따라서 전체 시스템을 이해하기 쉽고, 시스템을 설계하고 구현하기도 편리함.         
* 상하 계층에 인접한 모듈 사이의 인터페이스를 포함하여 분할된 모듈이 연동할 수 있는 표준 인터페이스를 제공. 모듈 인터페이스는 가능한 단순하게 구현하여 모듈들이 최대한 독립적으로 동작하도록 해야 함.   
➡ 모듈의 독립성은 전체 시스템의 구조를 단순하게 만들어줌.    
* 전송 매체 양단에 있는 호스트가 수행하는 프로토콜들은 좌우 대칭 구조임.    
➡ 대칭 구조에서는 통신 양단에 위치하는 동일 계층 사이의 프로토콜을 단순화가능.    
* 각 계층의 기능 오류를 수정하거나 향상시켜야 하는 경우에 전체 시스템을 재작성하지 않고 해당 계층의 모듈만 교체하면 됨.  
➡ 즉, 상하 혹은 좌우 계층 간의 인터페이스를 유지하면 특정 계층의 내부 변경이 다른 모듈의 동작에 영향을 미치지 않음.     



---



# **프로토콜 설계 시 고려 사항** 
계층 구조의 통신 프로토콜을 설계할 때는 고려할 요소           
* **네트워크 호스트의 주소 표현 방법**: 호스트를 유일하게 구분하는 용도로 사용함.      
* **데이터 전송 과정에서의 오류 제어**: 전송 과정에서 데이터 분실, 데이터 변형 등의 오류가 발생했을 때 데이터를 복구하는 데 사용함      
* **통신 양단 사이의 전송 속도를 제어 하는 흐름 제어**: 송신자가 데이터를 너무 빨리 보내어 수신자가 미처 처리하지 못하는 문제를 해결하기 위한 목적으로 사용함      


----

## 주소 표현
여러 호스트가 연결된 환경에서 특정 호스트끼리 통신하려면 상대방을 구분할 수 있는 방법이 필요함.     
시스템을 구분하여 지칭하기 위해서 이름을 부여하는 것을 주소 Address 체계라 한다.    
주소 체계는 시스템의 설계 과정에서 맨 먼저 고려해야 하는 중요한 개념이다.      



보통 호스트에도 주소를 하나씩 부여하지만, 다수의 호스트를 묶어 하나의 그룹 주소로 표기 하기도 한다.    
➡ 전통적인 통신 환경이면서 현재도 가장 많이 사용하는 일대일(1 :1) 통신과 더불어, 화상 회의 등을 지원하기 위한 일대다(1 :n) 통신 환경도 필요하기 때문임.      
➡ 일대다 통신의 대표적인 유형으로는 네트워크에 연결된 모든 호스트에 데이터를 전송할 수 있는 브로드캐스팅 Broadcasting 표기 방법과 특정 사용자를 그룹으로 묶어서 지칭하는 멀티캐스팅 Multicasting 표기 방법이 있음.    

----

## 오류 제어
네트워크에서는 데이터 송수신 과정에서 오류가 발생할 수 있음.     
* **전송 오류**: 데이터가 깨져서 도착하는 데이터 변형 오류와 데이터가 도착하지 못하는 데이터 분실 오류가 있음.    
* **오류 제어 Error Control**: 전송 오류 문제를 해결    
   * 통신 프로토콜의 가장 기본적인 기능에 속함     
   * 오류가 발생하는 1차 원인은 물리 계층의 전송 매체에 의한 물리적인 오류임.    
   ➡ 이를 해결하기 위해 데이터 링크 계층이 물리적인 전송 오류를 해결함.     
   ➡ 그리고 상위 계층의 프로토콜이 수행될 때는 논리적인 전송 오류가 발생할 수 있으므로 상위 계층에서도 전송 오류 문제를 다룸    


**[전송오류]**     
송신 호스트에서 보낸 데이터가 수신 호스트에 도착했을 때 발생할 수 있는 현상을 세 가지 유형으로 보면.   
![image](https://user-images.githubusercontent.com/76824611/163338212-4a90ed36-afef-43d7-be19-df0bf2aa3bcf.png)
* (a)는 데이터가 오류 없이 도착하는 정상적인 경우     
* (b)는 데이터가 수신 호스트에 도착하지 못하는 데이터 분실 오류    
* (c)는 데이터의 내용이 변경되어 도착하는 데이터 변형 오류    


**[데이터 분실 원인]**     
(b)처럼 데이터가 분실되는 원인은 매우 다양하다.    
* 전송 경로가 잘못되어 데이터가 엉뚱한 방향으로 전달     
* 상위 계층의 논리적 처리 과정에서 데이터 분실 가능       


**[오류 검출: (b)]**    
* 데이터가 변형되거나 분실되는 오류가 발생되어 이를 해결하려면 먼저 오류가 발생한 사실을 인지해야 함        
➡ (b)의 경우는 수신 호스트가 자신에게 데이터가 보내졌다는 사실을 인지하는 것이 쉽지 않다.     
그래서 보통은 **송신 호스트에서 오류를 감지하는 방법**을 사용한다.     


**[오류 검출: (c)]**    
* **수신 호스트**가 여러 방식의 오류 검출 기법을 이용해 오류를 검출 가능.     
* 네트워크에서 전송 오류를 해결하는 일반적인 방법은 **송신 호스트**가 원래 데이터를 **재전송 Retransmission** 하는 것임.     
* 물리적인 오류 외에도 통신 프로토콜에서 사용하는 알고리즘의 성격에 의해 오류가 발생하기도 한다. 예를 들어, 송신 호스트가 순차적으로 전송한 데이터의 순서가 뒤바뀌어 도착하는 경우이다. 수신 호스트에서 도착 순서를 바로잡으려면 데이터의 논리적인 순서를 의미하는 **순서 번호 기능이 필요**하다.    


----


## 흐름 제어
전송 매체에서 물리적인 오류가 없었는데도 데이터를 분실하는 경우가 있는데, 이는 **송수신 호스트 사이의 데이터 전송/처리 속도 차이** 때문에 발생하기도 한다.     
➡ 수신 호스트에 데이터가 도착하면 일단 내부 버퍼에 보관했다가 처리한다.     
➡ 그런데 내부 버퍼에 보관할 **공간을 확보**하지 못하면 **데이터**를 **논리적으로 분실**하는 결과가 초래된다.    

일반적으로 수신 호스트의 버퍼 처리 속도보다 **송신 호스트가 데이터를 전송하는 속도가 빠르면** 논리적인 데이터 분실 오류가 발생할 수 있음.      

이 문제를 해결하려면 송신 호스트의 전송 속도를 조절하는 **흐름 제어 Flow Control** 기능이 필요함.    



아래 그림은 는 가장 단순한 형태의 흐름 제어 기법을 보여줌.      
![image](https://user-images.githubusercontent.com/76824611/163343238-be12a503-b3a9-4236-974b-52e99cdb59a2.png)
송신 호스트가 데이터를 전송 하려면 반드시 수신 호스트로부터 명시적인 전송 허가를 받아야 함.        
* ❶: 송신 호스트가 i번째 데이터를 보내고 수신 호스트가 이를 제대로 받음      
    * 이후에 송신 호스트가 i+1번째 데이터를 보내려면 수신 호스트의 전송 허가가 필요함      
* ❷: 수신 호스트는 데이터를 수신할 여력이 있을 경우에만 전송 허가를 보냄     
    * 그림에서는 전송 허가를 수신한 후에 송신 호스트가 다음 데이터인 i+1을 전송하고 있음     
* ❸: 이와 같이 흐름 제어 기능은 보통 **수신 호스트의 제어**에 의해 이루어짐.    



----

## 데이터 전달 방식 
프로토콜 설계 시 고려할 마지막 사항은 데이터 전달 방식임      
* **단방향 Simplex 방식**: 일대일 통신 환경에서 데이터를 한쪽 방향으로만 전송하는 것      
* **전이중 Full Duplex 방식**: 양쪽에서 데이터를 동시에 전송하는 것       
일반적인 통신 프로토콜들은 모두 전이중 방식을 지원함.      
* **반이중 Half Duplex 방식**: 데이터가 양방향으로 전송되지만 특정 시점에는 한쪽 방향으로만 전송가능       
반이중 방식에서는 양쪽에서 데이터를 동시에 전송할 수 없으므로, **데이터 전송 시점을 제어**할 수 있어야 한다.    

데이터 전달 방식에서는 데이터 사이의 전송 우선순위를 설정하는 방법이나 긴급 데이터를 처리하는 방법 등도 고려해야 한다.

-----
----


# **서비스 프리미티브**
프로토콜은 계층 구조로 이루어져 있고, 하위 계층이 상위 계층에 서비스를 제공하는 방식으로 동작함.       
이러한 서비스는 다음에 살펴볼 **프리미티브 Primitive 형태**로 구현됨.      
계층 구조 프로토콜에서 하위 계층이 상위 계층에 제공하는 서비스의 종류에는 **연결형**과 **비연결형**이 있다.   
* **연결형 서비스(Connection-oriented) 이용 절차**  
연결형 서비스의 동작 원리는 전화 시스템을 이용한 통화 절차와 매우 유사하다   
    * **1)** 데이터 전달 경로를 설정하는 연결 설정 단계가 필요       
      ➡ 이 단계가 성공적으로 수행되어 연결이 설정되어야 다음 단계인 데이터 전송이 가능하다. 
    * **2)** 데이터 전송    
    * **3)** 모든 데이터의 전송이 완료되어 데이터 전송 단계를 끝내려면 연결을 끊는 연결 해제 단계 필요.     
.

* **비연결형 서비스(Connectionless)**     
우편 시스템의 동작 원리와 비슷.     
     * 연결을 설정하고 해제하는 단계가 필요 없다.   
     * 즉, 전송할 데이터가 있으면 각 데이터를 **독립적**으로 목적지 호스트로 전송하면 된다.     
     * 데이터는 독립적인 경로 선택 과정에 의해 전달되므로 **도착하는 순서가 보낸 순서와 일치하지 않을 수 있다**.


**[프리미티브 Primitive]**    
* **의미**: 하위 계층을 사용하는 방법을 정형화한 것임.   
* 하위 계층이 상위 계층에 제공하는 서비스는 프리미티브 Primitive 형태로 구현됨.     
* **연결형 서비스에서 자주 사용하는 서비스 프리미티브의 종류**     
     * **CONNECT**: 연결 설정    
     * **DATA**: 데이터 전송     
     * **DISCONNECT**: 연결 해제   
* **기능**    
통신 프로토콜에서 프리미티브를 올바르게 수행하려면 각 프리미티브를 아래의 네 가지 기능을 포함하도록 설계해야 함.     
설명의 편리함을 위하여 클라이언트와 서버라는 용어를 사용했음     
  * 클라이언트에서 서버로 전달되는 요청    
       * Request: 클라이언트가 서버에 서비스를 요청함    
       * Indication: 서버에 서비스 요청이 도착했음을 통지함     
  * 서버의 응답        
       * Response: 서버가 클라이언트에 서비스 응답을 회신함     
       * Confirm: 클라이언트에 응답이 도착했음을 통지함    


[그림 2-5]에서는 왼쪽 호스트를 클라이언트, 오른쪽 호스트를 서버로 가정했다. 


----


## 프리미티브가 처리되는 원리
![image](https://user-images.githubusercontent.com/76824611/163348989-00185e38-b710-446f-a383-9f4320c5723c.png)
* 1) 클라이언트로부터 Request가 발생하면 서버에 Indication 형태로 전달되어 서버가 인지함     
* 2) 서버에서는 해당 프리미티브를 올바르게 수신하였음을 클라이언트에 통보하기 위하여 Response를 응답으로 보내고, 이는 클라이언트에 Confirm 형태로 도착함.      
이와 같은 절차를 통해 하나의 서비스 프리미티브가 처리됨.     

**(전화 거는 사람을 클라이언트, 전화 받는 사람을 서버로 가정하여 예시 들기)**        
* 발신자가 전화번호를 누르면(Request) 전화망은 이 전화번호에 해당하는 전화기의 위치를 찾아 수신 자의 전화벨(Indication)이 울리게 한다.     
* 수신자가 전화를 받기 위해 통화 버튼을 누르면 (Response) 전화망은 이 사실을 바로 인지할 수 있다.    
* 수신자가 통화 버튼을 누름과 동시에 발신자 전화기의 발신음이 끊기면서(Confirm) 통화 연결 상태가 되었음을 확인할 수 있다.

-----

## 프리미티브의 4단계 
**[Request]**    
* Request는 클라이언트에서 발생하며, 서버가 프리미티브의 기능을 수행하도록 하위 프로토콜에 요청할 때 사용한다.      
* 연결 설정 요청 CONNECT.Request, 데이터 전송 요청 DATA.Request , 연결 해제 요청 DISCONNECT.Request 등이 있다.    


**[Indication]**   
* 클라이언트로부터 Request 요청을 수신한 서버의 하위 프로토콜은 Indication을 사용 해서 프리미티브 요청이 발생했음을 알림.     
* 연결 설정, 데이터 전송, 연결 해제에 대해 CONNECT.Indication, DATA.Indication, DISCONNECT.Indication 순으로 사용.     


**[Response]**     
* 클라이언트로부터 프리미티브를 받은 서버에서는 Response를 이용해 클라이언트에 응답함.     
* 연결 설정 요청은 CONNECT.Response를 사용해 연결 허용이나 거부로 응답하고, 데이터는 DATA.Response, 연결해제는 DISCONNECT.Response로 전달함.


**[Confirm]**    
* 서버에서 보낸 응답은 Confirm 형태로 클라이언트에 회신된다.    
* 연결 설정은 CONNECT.Confirm, 데이터는 DATA.Confirm, 연결 해제는 DISCONNECT.Confirm로 전달된다.














